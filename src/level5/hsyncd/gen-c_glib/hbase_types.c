/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "hbase_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_TDeleteType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case T_DELETE_TYPE_DELETE_COLUMN:return "T_DELETE_TYPE_DELETE_COLUMN";
  case T_DELETE_TYPE_DELETE_COLUMNS:return "T_DELETE_TYPE_DELETE_COLUMNS";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_TDurability(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case T_DURABILITY_SKIP_WAL:return "T_DURABILITY_SKIP_WAL";
  case T_DURABILITY_ASYNC_WAL:return "T_DURABILITY_ASYNC_WAL";
  case T_DURABILITY_SYNC_WAL:return "T_DURABILITY_SYNC_WAL";
  case T_DURABILITY_FSYNC_WAL:return "T_DURABILITY_FSYNC_WAL";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_TCompareOp(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case T_COMPARE_OP_LESS:return "T_COMPARE_OP_LESS";
  case T_COMPARE_OP_LESS_OR_EQUAL:return "T_COMPARE_OP_LESS_OR_EQUAL";
  case T_COMPARE_OP_EQUAL:return "T_COMPARE_OP_EQUAL";
  case T_COMPARE_OP_NOT_EQUAL:return "T_COMPARE_OP_NOT_EQUAL";
  case T_COMPARE_OP_GREATER_OR_EQUAL:return "T_COMPARE_OP_GREATER_OR_EQUAL";
  case T_COMPARE_OP_GREATER:return "T_COMPARE_OP_GREATER";
  case T_COMPARE_OP_NO_OP:return "T_COMPARE_OP_NO_OP";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _TTimeRangeProperties
{
  PROP_T_TIME_RANGE_0,
  PROP_T_TIME_RANGE_MIN_STAMP,
  PROP_T_TIME_RANGE_MAX_STAMP
};

/* reads a t_time_range object */
static gint32
t_time_range_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TTimeRange * this_object = T_TIME_RANGE(object);
  gboolean isset_minStamp = FALSE;
  gboolean isset_maxStamp = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->minStamp, error)) < 0)
            return -1;
          xfer += ret;
          isset_minStamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->maxStamp, error)) < 0)
            return -1;
          xfer += ret;
          isset_maxStamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_minStamp)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_maxStamp)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_time_range_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TTimeRange * this_object = T_TIME_RANGE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TTimeRange", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "minStamp", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->minStamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "maxStamp", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->maxStamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_time_range_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  TTimeRange *self = T_TIME_RANGE (object);

  switch (property_id)
  {
    case PROP_T_TIME_RANGE_MIN_STAMP:
      self->minStamp = g_value_get_int64 (value);
      break;

    case PROP_T_TIME_RANGE_MAX_STAMP:
      self->maxStamp = g_value_get_int64 (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_time_range_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  TTimeRange *self = T_TIME_RANGE (object);

  switch (property_id)
  {
    case PROP_T_TIME_RANGE_MIN_STAMP:
      g_value_set_int64 (value, self->minStamp);
      break;

    case PROP_T_TIME_RANGE_MAX_STAMP:
      g_value_set_int64 (value, self->maxStamp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_time_range_instance_init (TTimeRange * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->minStamp = 0;
  object->maxStamp = 0;
}

static void 
t_time_range_finalize (GObject *object)
{
  TTimeRange *tobject = T_TIME_RANGE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_time_range_class_init (TTimeRangeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_time_range_read;
  struct_class->write = t_time_range_write;

  gobject_class->finalize = t_time_range_finalize;
  gobject_class->get_property = t_time_range_get_property;
  gobject_class->set_property = t_time_range_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_TIME_RANGE_MIN_STAMP,
     g_param_spec_int64 ("minStamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_TIME_RANGE_MAX_STAMP,
     g_param_spec_int64 ("maxStamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
t_time_range_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TTimeRangeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_time_range_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TTimeRange),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_time_range_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TTimeRangeType",
                                   &type_info, 0);
  }

  return type;
}

enum _TColumnProperties
{
  PROP_T_COLUMN_0,
  PROP_T_COLUMN_FAMILY,
  PROP_T_COLUMN_QUALIFIER,
  PROP_T_COLUMN_TIMESTAMP
};

/* reads a t_column object */
static gint32
t_column_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TColumn * this_object = T_COLUMN(object);
  gboolean isset_family = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->family != NULL)
          {
            g_free(this_object->family);
            this_object->family = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->family = g_byte_array_new();
          g_byte_array_append (this_object->family, (guint8 *) data, (guint) len);
          g_free (data);
          isset_family = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->qualifier != NULL)
          {
            g_free(this_object->qualifier);
            this_object->qualifier = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->qualifier = g_byte_array_new();
          g_byte_array_append (this_object->qualifier, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_qualifier = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_family)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_column_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TColumn * this_object = T_COLUMN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TColumn", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "family", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->family ? ((GByteArray *) this_object->family)->data : NULL, this_object->family ? ((GByteArray *) this_object->family)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_qualifier == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "qualifier", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->qualifier ? ((GByteArray *) this_object->qualifier)->data : NULL, this_object->qualifier ? ((GByteArray *) this_object->qualifier)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_timestamp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_column_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  TColumn *self = T_COLUMN (object);

  switch (property_id)
  {
    case PROP_T_COLUMN_FAMILY:
      if (self->family != NULL)
        g_byte_array_unref (self->family);
      self->family = g_value_dup_boxed (value);
      break;

    case PROP_T_COLUMN_QUALIFIER:
      if (self->qualifier != NULL)
        g_byte_array_unref (self->qualifier);
      self->qualifier = g_value_dup_boxed (value);
      self->__isset_qualifier = TRUE;
      break;

    case PROP_T_COLUMN_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      self->__isset_timestamp = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_column_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  TColumn *self = T_COLUMN (object);

  switch (property_id)
  {
    case PROP_T_COLUMN_FAMILY:
      g_value_set_boxed (value, self->family);
      break;

    case PROP_T_COLUMN_QUALIFIER:
      g_value_set_boxed (value, self->qualifier);
      break;

    case PROP_T_COLUMN_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_column_instance_init (TColumn * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->family = NULL;
  object->qualifier = NULL;
  object->__isset_qualifier = FALSE;
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
}

static void 
t_column_finalize (GObject *object)
{
  TColumn *tobject = T_COLUMN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->family != NULL)
  {
    thrift_string_free(tobject->family);
    tobject->family = NULL;
  }
  if (tobject->qualifier != NULL)
  {
    thrift_string_free(tobject->qualifier);
    tobject->qualifier = NULL;
  }
}

static void
t_column_class_init (TColumnClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_column_read;
  struct_class->write = t_column_write;

  gobject_class->finalize = t_column_finalize;
  gobject_class->get_property = t_column_get_property;
  gobject_class->set_property = t_column_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_COLUMN_FAMILY,
     g_param_spec_boxed ("family",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_COLUMN_QUALIFIER,
     g_param_spec_boxed ("qualifier",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_COLUMN_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
t_column_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TColumnClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_column_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TColumn),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_column_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TColumnType",
                                   &type_info, 0);
  }

  return type;
}

enum _TColumnValueProperties
{
  PROP_T_COLUMN_VALUE_0,
  PROP_T_COLUMN_VALUE_FAMILY,
  PROP_T_COLUMN_VALUE_QUALIFIER,
  PROP_T_COLUMN_VALUE_VALUE,
  PROP_T_COLUMN_VALUE_TIMESTAMP,
  PROP_T_COLUMN_VALUE_TAGS
};

/* reads a t_column_value object */
static gint32
t_column_value_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TColumnValue * this_object = T_COLUMN_VALUE(object);
  gboolean isset_family = FALSE;
  gboolean isset_qualifier = FALSE;
  gboolean isset_value = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->family != NULL)
          {
            g_free(this_object->family);
            this_object->family = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->family = g_byte_array_new();
          g_byte_array_append (this_object->family, (guint8 *) data, (guint) len);
          g_free (data);
          isset_family = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->qualifier != NULL)
          {
            g_free(this_object->qualifier);
            this_object->qualifier = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->qualifier = g_byte_array_new();
          g_byte_array_append (this_object->qualifier, (guint8 *) data, (guint) len);
          g_free (data);
          isset_qualifier = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->value = g_byte_array_new();
          g_byte_array_append (this_object->value, (guint8 *) data, (guint) len);
          g_free (data);
          isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->tags != NULL)
          {
            g_free(this_object->tags);
            this_object->tags = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tags = g_byte_array_new();
          g_byte_array_append (this_object->tags, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tags = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_family)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_qualifier)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_value)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_column_value_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TColumnValue * this_object = T_COLUMN_VALUE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TColumnValue", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "family", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->family ? ((GByteArray *) this_object->family)->data : NULL, this_object->family ? ((GByteArray *) this_object->family)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "qualifier", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->qualifier ? ((GByteArray *) this_object->qualifier)->data : NULL, this_object->qualifier ? ((GByteArray *) this_object->qualifier)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->value ? ((GByteArray *) this_object->value)->data : NULL, this_object->value ? ((GByteArray *) this_object->value)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_timestamp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_tags == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "tags", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->tags ? ((GByteArray *) this_object->tags)->data : NULL, this_object->tags ? ((GByteArray *) this_object->tags)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_column_value_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  TColumnValue *self = T_COLUMN_VALUE (object);

  switch (property_id)
  {
    case PROP_T_COLUMN_VALUE_FAMILY:
      if (self->family != NULL)
        g_byte_array_unref (self->family);
      self->family = g_value_dup_boxed (value);
      break;

    case PROP_T_COLUMN_VALUE_QUALIFIER:
      if (self->qualifier != NULL)
        g_byte_array_unref (self->qualifier);
      self->qualifier = g_value_dup_boxed (value);
      break;

    case PROP_T_COLUMN_VALUE_VALUE:
      if (self->value != NULL)
        g_byte_array_unref (self->value);
      self->value = g_value_dup_boxed (value);
      break;

    case PROP_T_COLUMN_VALUE_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_T_COLUMN_VALUE_TAGS:
      if (self->tags != NULL)
        g_byte_array_unref (self->tags);
      self->tags = g_value_dup_boxed (value);
      self->__isset_tags = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_column_value_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  TColumnValue *self = T_COLUMN_VALUE (object);

  switch (property_id)
  {
    case PROP_T_COLUMN_VALUE_FAMILY:
      g_value_set_boxed (value, self->family);
      break;

    case PROP_T_COLUMN_VALUE_QUALIFIER:
      g_value_set_boxed (value, self->qualifier);
      break;

    case PROP_T_COLUMN_VALUE_VALUE:
      g_value_set_boxed (value, self->value);
      break;

    case PROP_T_COLUMN_VALUE_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    case PROP_T_COLUMN_VALUE_TAGS:
      g_value_set_boxed (value, self->tags);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_column_value_instance_init (TColumnValue * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->family = NULL;
  object->qualifier = NULL;
  object->value = NULL;
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
  object->tags = NULL;
  object->__isset_tags = FALSE;
}

static void 
t_column_value_finalize (GObject *object)
{
  TColumnValue *tobject = T_COLUMN_VALUE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->family != NULL)
  {
    thrift_string_free(tobject->family);
    tobject->family = NULL;
  }
  if (tobject->qualifier != NULL)
  {
    thrift_string_free(tobject->qualifier);
    tobject->qualifier = NULL;
  }
  if (tobject->value != NULL)
  {
    thrift_string_free(tobject->value);
    tobject->value = NULL;
  }
  if (tobject->tags != NULL)
  {
    thrift_string_free(tobject->tags);
    tobject->tags = NULL;
  }
}

static void
t_column_value_class_init (TColumnValueClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_column_value_read;
  struct_class->write = t_column_value_write;

  gobject_class->finalize = t_column_value_finalize;
  gobject_class->get_property = t_column_value_get_property;
  gobject_class->set_property = t_column_value_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_COLUMN_VALUE_FAMILY,
     g_param_spec_boxed ("family",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_COLUMN_VALUE_QUALIFIER,
     g_param_spec_boxed ("qualifier",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_COLUMN_VALUE_VALUE,
     g_param_spec_boxed ("value",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_COLUMN_VALUE_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_COLUMN_VALUE_TAGS,
     g_param_spec_boxed ("tags",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_column_value_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TColumnValueClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_column_value_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TColumnValue),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_column_value_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TColumnValueType",
                                   &type_info, 0);
  }

  return type;
}

enum _TColumnIncrementProperties
{
  PROP_T_COLUMN_INCREMENT_0,
  PROP_T_COLUMN_INCREMENT_FAMILY,
  PROP_T_COLUMN_INCREMENT_QUALIFIER,
  PROP_T_COLUMN_INCREMENT_AMOUNT
};

/* reads a t_column_increment object */
static gint32
t_column_increment_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TColumnIncrement * this_object = T_COLUMN_INCREMENT(object);
  gboolean isset_family = FALSE;
  gboolean isset_qualifier = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->family != NULL)
          {
            g_free(this_object->family);
            this_object->family = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->family = g_byte_array_new();
          g_byte_array_append (this_object->family, (guint8 *) data, (guint) len);
          g_free (data);
          isset_family = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->qualifier != NULL)
          {
            g_free(this_object->qualifier);
            this_object->qualifier = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->qualifier = g_byte_array_new();
          g_byte_array_append (this_object->qualifier, (guint8 *) data, (guint) len);
          g_free (data);
          isset_qualifier = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->amount, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_amount = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_family)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_qualifier)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_column_increment_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TColumnIncrement * this_object = T_COLUMN_INCREMENT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TColumnIncrement", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "family", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->family ? ((GByteArray *) this_object->family)->data : NULL, this_object->family ? ((GByteArray *) this_object->family)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "qualifier", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->qualifier ? ((GByteArray *) this_object->qualifier)->data : NULL, this_object->qualifier ? ((GByteArray *) this_object->qualifier)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_amount == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "amount", T_I64, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->amount, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_column_increment_set_property (GObject *object,
                                 guint property_id,
                                 const GValue *value,
                                 GParamSpec *pspec)
{
  TColumnIncrement *self = T_COLUMN_INCREMENT (object);

  switch (property_id)
  {
    case PROP_T_COLUMN_INCREMENT_FAMILY:
      if (self->family != NULL)
        g_byte_array_unref (self->family);
      self->family = g_value_dup_boxed (value);
      break;

    case PROP_T_COLUMN_INCREMENT_QUALIFIER:
      if (self->qualifier != NULL)
        g_byte_array_unref (self->qualifier);
      self->qualifier = g_value_dup_boxed (value);
      break;

    case PROP_T_COLUMN_INCREMENT_AMOUNT:
      self->amount = g_value_get_int64 (value);
      self->__isset_amount = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_column_increment_get_property (GObject *object,
                                 guint property_id,
                                 GValue *value,
                                 GParamSpec *pspec)
{
  TColumnIncrement *self = T_COLUMN_INCREMENT (object);

  switch (property_id)
  {
    case PROP_T_COLUMN_INCREMENT_FAMILY:
      g_value_set_boxed (value, self->family);
      break;

    case PROP_T_COLUMN_INCREMENT_QUALIFIER:
      g_value_set_boxed (value, self->qualifier);
      break;

    case PROP_T_COLUMN_INCREMENT_AMOUNT:
      g_value_set_int64 (value, self->amount);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_column_increment_instance_init (TColumnIncrement * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->family = NULL;
  object->qualifier = NULL;
  object->amount = G_GINT64_CONSTANT (1);
  object->__isset_amount = FALSE;
}

static void 
t_column_increment_finalize (GObject *object)
{
  TColumnIncrement *tobject = T_COLUMN_INCREMENT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->family != NULL)
  {
    thrift_string_free(tobject->family);
    tobject->family = NULL;
  }
  if (tobject->qualifier != NULL)
  {
    thrift_string_free(tobject->qualifier);
    tobject->qualifier = NULL;
  }
}

static void
t_column_increment_class_init (TColumnIncrementClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_column_increment_read;
  struct_class->write = t_column_increment_write;

  gobject_class->finalize = t_column_increment_finalize;
  gobject_class->get_property = t_column_increment_get_property;
  gobject_class->set_property = t_column_increment_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_COLUMN_INCREMENT_FAMILY,
     g_param_spec_boxed ("family",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_COLUMN_INCREMENT_QUALIFIER,
     g_param_spec_boxed ("qualifier",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_COLUMN_INCREMENT_AMOUNT,
     g_param_spec_int64 ("amount",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         1,
                         G_PARAM_READWRITE));
}

GType
t_column_increment_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TColumnIncrementClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_column_increment_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TColumnIncrement),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_column_increment_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TColumnIncrementType",
                                   &type_info, 0);
  }

  return type;
}

enum _TResultProperties
{
  PROP_T_RESULT_0,
  PROP_T_RESULT_ROW,
  PROP_T_RESULT_COLUMN_VALUES
};

/* reads a t_result object */
static gint32
t_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TResult * this_object = T_RESULT(object);
  gboolean isset_columnValues = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TColumnValue * _elem0 = NULL;
              if ( _elem0 != NULL)
              {
                g_object_unref (_elem0);
              }
              _elem0 = g_object_new (TYPE_T_COLUMN_VALUE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem0), protocol, error)) < 0)
              {
                g_object_unref (_elem0);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->columnValues, _elem0);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_columnValues = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_columnValues)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TResult * this_object = T_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_row == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "columnValues", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i1;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->columnValues ? this_object->columnValues->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i1 = 0; i1 < (this_object->columnValues ? this_object->columnValues->len : 0); i1++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->columnValues, i1))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_result_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  TResult *self = T_RESULT (object);

  switch (property_id)
  {
    case PROP_T_RESULT_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_T_RESULT_COLUMN_VALUES:
      if (self->columnValues != NULL)
        g_ptr_array_unref (self->columnValues);
      self->columnValues = g_value_dup_boxed (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_result_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  TResult *self = T_RESULT (object);

  switch (property_id)
  {
    case PROP_T_RESULT_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_T_RESULT_COLUMN_VALUES:
      g_value_set_boxed (value, self->columnValues);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_result_instance_init (TResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->row = NULL;
  object->__isset_row = FALSE;
  object->columnValues = g_ptr_array_new_with_free_func (g_object_unref);
}

static void 
t_result_finalize (GObject *object)
{
  TResult *tobject = T_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->columnValues != NULL)
  {
    g_ptr_array_unref (tobject->columnValues);
    tobject->columnValues = NULL;
  }
}

static void
t_result_class_init (TResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_result_read;
  struct_class->write = t_result_write;

  gobject_class->finalize = t_result_finalize;
  gobject_class->get_property = t_result_get_property;
  gobject_class->set_property = t_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_RESULT_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_RESULT_COLUMN_VALUES,
     g_param_spec_boxed ("columnValues",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TAuthorizationProperties
{
  PROP_T_AUTHORIZATION_0,
  PROP_T_AUTHORIZATION_LABELS
};

/* reads a t_authorization object */
static gint32
t_authorization_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TAuthorization * this_object = T_AUTHORIZATION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem2 = NULL;
              if (_elem2 != NULL)
              {
                g_free(_elem2);
                _elem2 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem2, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->labels, _elem2);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_labels = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_authorization_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TAuthorization * this_object = T_AUTHORIZATION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TAuthorization", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_labels == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "labels", T_LIST, 1, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i3;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->labels ? this_object->labels->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i3 = 0; i3 < (this_object->labels ? this_object->labels->len : 0); i3++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->labels, i3)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_authorization_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  TAuthorization *self = T_AUTHORIZATION (object);

  switch (property_id)
  {
    case PROP_T_AUTHORIZATION_LABELS:
      if (self->labels != NULL)
        g_ptr_array_unref (self->labels);
      self->labels = g_value_dup_boxed (value);
      self->__isset_labels = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_authorization_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  TAuthorization *self = T_AUTHORIZATION (object);

  switch (property_id)
  {
    case PROP_T_AUTHORIZATION_LABELS:
      g_value_set_boxed (value, self->labels);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_authorization_instance_init (TAuthorization * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->labels = g_ptr_array_new_with_free_func (g_free);
  object->__isset_labels = FALSE;
}

static void 
t_authorization_finalize (GObject *object)
{
  TAuthorization *tobject = T_AUTHORIZATION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->labels != NULL)
  {
    g_ptr_array_unref (tobject->labels);
    tobject->labels = NULL;
  }
}

static void
t_authorization_class_init (TAuthorizationClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_authorization_read;
  struct_class->write = t_authorization_write;

  gobject_class->finalize = t_authorization_finalize;
  gobject_class->get_property = t_authorization_get_property;
  gobject_class->set_property = t_authorization_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_AUTHORIZATION_LABELS,
     g_param_spec_boxed ("labels",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_authorization_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TAuthorizationClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_authorization_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TAuthorization),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_authorization_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TAuthorizationType",
                                   &type_info, 0);
  }

  return type;
}

enum _TCellVisibilityProperties
{
  PROP_T_CELL_VISIBILITY_0,
  PROP_T_CELL_VISIBILITY_EXPRESSION
};

/* reads a t_cell_visibility object */
static gint32
t_cell_visibility_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TCellVisibility * this_object = T_CELL_VISIBILITY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->expression != NULL)
          {
            g_free(this_object->expression);
            this_object->expression = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->expression, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_expression = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_cell_visibility_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TCellVisibility * this_object = T_CELL_VISIBILITY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TCellVisibility", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_expression == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "expression", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->expression, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_cell_visibility_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  TCellVisibility *self = T_CELL_VISIBILITY (object);

  switch (property_id)
  {
    case PROP_T_CELL_VISIBILITY_EXPRESSION:
      if (self->expression != NULL)
        g_free (self->expression);
      self->expression = g_value_dup_string (value);
      self->__isset_expression = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_cell_visibility_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  TCellVisibility *self = T_CELL_VISIBILITY (object);

  switch (property_id)
  {
    case PROP_T_CELL_VISIBILITY_EXPRESSION:
      g_value_set_string (value, self->expression);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_cell_visibility_instance_init (TCellVisibility * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->expression = NULL;
  object->__isset_expression = FALSE;
}

static void 
t_cell_visibility_finalize (GObject *object)
{
  TCellVisibility *tobject = T_CELL_VISIBILITY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->expression != NULL)
  {
    g_free(tobject->expression);
    tobject->expression = NULL;
  }
}

static void
t_cell_visibility_class_init (TCellVisibilityClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_cell_visibility_read;
  struct_class->write = t_cell_visibility_write;

  gobject_class->finalize = t_cell_visibility_finalize;
  gobject_class->get_property = t_cell_visibility_get_property;
  gobject_class->set_property = t_cell_visibility_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_CELL_VISIBILITY_EXPRESSION,
     g_param_spec_string ("expression",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
t_cell_visibility_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TCellVisibilityClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_cell_visibility_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TCellVisibility),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_cell_visibility_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TCellVisibilityType",
                                   &type_info, 0);
  }

  return type;
}

enum _TGetProperties
{
  PROP_T_GET_0,
  PROP_T_GET_ROW,
  PROP_T_GET_COLUMNS,
  PROP_T_GET_TIMESTAMP,
  PROP_T_GET_TIME_RANGE,
  PROP_T_GET_MAX_VERSIONS,
  PROP_T_GET_FILTER_STRING,
  PROP_T_GET_ATTRIBUTES,
  PROP_T_GET_AUTHORIZATIONS
};

/* reads a t_get object */
static gint32
t_get_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TGet * this_object = T_GET(object);
  gboolean isset_row = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TColumn * _elem4 = NULL;
              if ( _elem4 != NULL)
              {
                g_object_unref (_elem4);
              }
              _elem4 = g_object_new (TYPE_T_COLUMN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem4), protocol, error)) < 0)
              {
                g_object_unref (_elem4);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->columns, _elem4);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->timeRange), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_timeRange = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->maxVersions, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_maxVersions = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->filterString != NULL)
          {
            g_free(this_object->filterString);
            this_object->filterString = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->filterString = g_byte_array_new();
          g_byte_array_append (this_object->filterString, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_filterString = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GByteArray * key5 = NULL;
              GByteArray * val6 = NULL;
              if (key5 != NULL)
              {
                g_free(key5);
                key5 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key5 = g_byte_array_new();
              g_byte_array_append (key5, (guint8 *) data, (guint) len);
              g_free (data);
              if (val6 != NULL)
              {
                g_free(val6);
                val6 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val6 = g_byte_array_new();
              g_byte_array_append (val6, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key5)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key5, (gpointer) val6);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->authorizations), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_authorizations = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_row)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_get_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TGet * this_object = T_GET(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TGet", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_columns == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i7;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i7 = 0; i7 < (this_object->columns ? this_object->columns->len : 0); i7++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->columns, i7))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_timestamp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_timeRange == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "timeRange", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->timeRange), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_maxVersions == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "maxVersions", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->maxVersions, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_filterString == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "filterString", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->filterString ? ((GByteArray *) this_object->filterString)->data : NULL, this_object->filterString ? ((GByteArray *) this_object->filterString)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_attributes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 7, error)) < 0)
      return -1;
    xfer += ret;
    {
      GByteArray * key8 = NULL;
      GByteArray * val9 = NULL;
      GList *key_list = NULL, *iter = NULL;
      GByteArray ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->attributes)
        g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (GByteArray *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (GByteArray *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key8 = keys[i];
        val9 = (GByteArray *) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key8);

        if ((ret = thrift_protocol_write_binary (protocol,  key8 ? ((GByteArray *)  key8)->data : NULL,  key8 ? ((GByteArray *)  key8)->len : 0, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val9 ? ((GByteArray *)  val9)->data : NULL,  val9 ? ((GByteArray *)  val9)->len : 0, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_authorizations == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "authorizations", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->authorizations), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_get_set_property (GObject *object,
                    guint property_id,
                    const GValue *value,
                    GParamSpec *pspec)
{
  TGet *self = T_GET (object);

  switch (property_id)
  {
    case PROP_T_GET_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      break;

    case PROP_T_GET_COLUMNS:
      if (self->columns != NULL)
        g_ptr_array_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      self->__isset_columns = TRUE;
      break;

    case PROP_T_GET_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_T_GET_TIME_RANGE:
      if (self->timeRange != NULL)
        g_object_unref (self->timeRange);
      self->timeRange = g_value_dup_object (value);
      self->__isset_timeRange = TRUE;
      break;

    case PROP_T_GET_MAX_VERSIONS:
      self->maxVersions = g_value_get_int (value);
      self->__isset_maxVersions = TRUE;
      break;

    case PROP_T_GET_FILTER_STRING:
      if (self->filterString != NULL)
        g_byte_array_unref (self->filterString);
      self->filterString = g_value_dup_boxed (value);
      self->__isset_filterString = TRUE;
      break;

    case PROP_T_GET_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    case PROP_T_GET_AUTHORIZATIONS:
      if (self->authorizations != NULL)
        g_object_unref (self->authorizations);
      self->authorizations = g_value_dup_object (value);
      self->__isset_authorizations = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_get_get_property (GObject *object,
                    guint property_id,
                    GValue *value,
                    GParamSpec *pspec)
{
  TGet *self = T_GET (object);

  switch (property_id)
  {
    case PROP_T_GET_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_T_GET_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_T_GET_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    case PROP_T_GET_TIME_RANGE:
      g_value_set_object (value, self->timeRange);
      break;

    case PROP_T_GET_MAX_VERSIONS:
      g_value_set_int (value, self->maxVersions);
      break;

    case PROP_T_GET_FILTER_STRING:
      g_value_set_boxed (value, self->filterString);
      break;

    case PROP_T_GET_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    case PROP_T_GET_AUTHORIZATIONS:
      g_value_set_object (value, self->authorizations);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_get_instance_init (TGet * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->row = NULL;
  object->columns = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_columns = FALSE;
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
  object->timeRange = g_object_new (TYPE_T_TIME_RANGE, NULL);
  object->__isset_timeRange = FALSE;
  object->maxVersions = 0;
  object->__isset_maxVersions = FALSE;
  object->filterString = NULL;
  object->__isset_filterString = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
  object->authorizations = g_object_new (TYPE_T_AUTHORIZATION, NULL);
  object->__isset_authorizations = FALSE;
}

static void 
t_get_finalize (GObject *object)
{
  TGet *tobject = T_GET (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->timeRange != NULL)
  {
    g_object_unref(tobject->timeRange);
    tobject->timeRange = NULL;
  }
  if (tobject->filterString != NULL)
  {
    thrift_string_free(tobject->filterString);
    tobject->filterString = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
  if (tobject->authorizations != NULL)
  {
    g_object_unref(tobject->authorizations);
    tobject->authorizations = NULL;
  }
}

static void
t_get_class_init (TGetClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_get_read;
  struct_class->write = t_get_write;

  gobject_class->finalize = t_get_finalize;
  gobject_class->get_property = t_get_get_property;
  gobject_class->set_property = t_get_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_GET_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_GET_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_GET_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_GET_TIME_RANGE,
     g_param_spec_object ("timeRange",
                         NULL,
                         NULL,
                         TYPE_T_TIME_RANGE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_GET_MAX_VERSIONS,
     g_param_spec_int ("maxVersions",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_GET_FILTER_STRING,
     g_param_spec_boxed ("filterString",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_GET_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_GET_AUTHORIZATIONS,
     g_param_spec_object ("authorizations",
                         NULL,
                         NULL,
                         TYPE_T_AUTHORIZATION,
                         G_PARAM_READWRITE));
}

GType
t_get_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TGetClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_get_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TGet),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_get_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TGetType",
                                   &type_info, 0);
  }

  return type;
}

enum _TPutProperties
{
  PROP_T_PUT_0,
  PROP_T_PUT_ROW,
  PROP_T_PUT_COLUMN_VALUES,
  PROP_T_PUT_TIMESTAMP,
  PROP_T_PUT_ATTRIBUTES,
  PROP_T_PUT_DURABILITY,
  PROP_T_PUT_CELL_VISIBILITY
};

/* reads a t_put object */
static gint32
t_put_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TPut * this_object = T_PUT(object);
  gboolean isset_row = FALSE;
  gboolean isset_columnValues = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TColumnValue * _elem10 = NULL;
              if ( _elem10 != NULL)
              {
                g_object_unref (_elem10);
              }
              _elem10 = g_object_new (TYPE_T_COLUMN_VALUE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem10), protocol, error)) < 0)
              {
                g_object_unref (_elem10);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->columnValues, _elem10);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_columnValues = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GByteArray * key11 = NULL;
              GByteArray * val12 = NULL;
              if (key11 != NULL)
              {
                g_free(key11);
                key11 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key11 = g_byte_array_new();
              g_byte_array_append (key11, (guint8 *) data, (guint) len);
              g_free (data);
              if (val12 != NULL)
              {
                g_free(val12);
                val12 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val12 = g_byte_array_new();
              g_byte_array_append (val12, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key11)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key11, (gpointer) val12);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          gint32 ecast13;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast13, error)) < 0)
            return -1;
          xfer += ret;
          this_object->durability = (TDurability)ecast13;
          this_object->__isset_durability = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->cellVisibility), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_cellVisibility = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_row)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_columnValues)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_put_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TPut * this_object = T_PUT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TPut", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columnValues", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i14;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->columnValues ? this_object->columnValues->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i14 = 0; i14 < (this_object->columnValues ? this_object->columnValues->len : 0); i14++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->columnValues, i14))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_timestamp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_attributes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      GByteArray * key15 = NULL;
      GByteArray * val16 = NULL;
      GList *key_list = NULL, *iter = NULL;
      GByteArray ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->attributes)
        g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (GByteArray *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (GByteArray *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key15 = keys[i];
        val16 = (GByteArray *) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key15);

        if ((ret = thrift_protocol_write_binary (protocol,  key15 ? ((GByteArray *)  key15)->data : NULL,  key15 ? ((GByteArray *)  key15)->len : 0, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val16 ? ((GByteArray *)  val16)->data : NULL,  val16 ? ((GByteArray *)  val16)->len : 0, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_durability == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "durability", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->durability, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_cellVisibility == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cellVisibility", T_STRUCT, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->cellVisibility), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_put_set_property (GObject *object,
                    guint property_id,
                    const GValue *value,
                    GParamSpec *pspec)
{
  TPut *self = T_PUT (object);

  switch (property_id)
  {
    case PROP_T_PUT_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      break;

    case PROP_T_PUT_COLUMN_VALUES:
      if (self->columnValues != NULL)
        g_ptr_array_unref (self->columnValues);
      self->columnValues = g_value_dup_boxed (value);
      break;

    case PROP_T_PUT_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_T_PUT_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    case PROP_T_PUT_DURABILITY:
      self->durability = g_value_get_int (value);
      self->__isset_durability = TRUE;
      break;

    case PROP_T_PUT_CELL_VISIBILITY:
      if (self->cellVisibility != NULL)
        g_object_unref (self->cellVisibility);
      self->cellVisibility = g_value_dup_object (value);
      self->__isset_cellVisibility = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_put_get_property (GObject *object,
                    guint property_id,
                    GValue *value,
                    GParamSpec *pspec)
{
  TPut *self = T_PUT (object);

  switch (property_id)
  {
    case PROP_T_PUT_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_T_PUT_COLUMN_VALUES:
      g_value_set_boxed (value, self->columnValues);
      break;

    case PROP_T_PUT_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    case PROP_T_PUT_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    case PROP_T_PUT_DURABILITY:
      g_value_set_int (value, self->durability);
      break;

    case PROP_T_PUT_CELL_VISIBILITY:
      g_value_set_object (value, self->cellVisibility);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_put_instance_init (TPut * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->row = NULL;
  object->columnValues = g_ptr_array_new_with_free_func (g_object_unref);
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
  object->__isset_durability = FALSE;
  object->cellVisibility = g_object_new (TYPE_T_CELL_VISIBILITY, NULL);
  object->__isset_cellVisibility = FALSE;
}

static void 
t_put_finalize (GObject *object)
{
  TPut *tobject = T_PUT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->columnValues != NULL)
  {
    g_ptr_array_unref (tobject->columnValues);
    tobject->columnValues = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
  if (tobject->cellVisibility != NULL)
  {
    g_object_unref(tobject->cellVisibility);
    tobject->cellVisibility = NULL;
  }
}

static void
t_put_class_init (TPutClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_put_read;
  struct_class->write = t_put_write;

  gobject_class->finalize = t_put_finalize;
  gobject_class->get_property = t_put_get_property;
  gobject_class->set_property = t_put_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_PUT_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_PUT_COLUMN_VALUES,
     g_param_spec_boxed ("columnValues",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_PUT_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_PUT_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_PUT_DURABILITY,
     g_param_spec_int ("durability",
                       NULL,
                       NULL,
                       1,
                       4,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_PUT_CELL_VISIBILITY,
     g_param_spec_object ("cellVisibility",
                         NULL,
                         NULL,
                         TYPE_T_CELL_VISIBILITY,
                         G_PARAM_READWRITE));
}

GType
t_put_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TPutClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_put_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TPut),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_put_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TPutType",
                                   &type_info, 0);
  }

  return type;
}

enum _TDeleteProperties
{
  PROP_T_DELETE_0,
  PROP_T_DELETE_ROW,
  PROP_T_DELETE_COLUMNS,
  PROP_T_DELETE_TIMESTAMP,
  PROP_T_DELETE_DELETE_TYPE,
  PROP_T_DELETE_ATTRIBUTES,
  PROP_T_DELETE_DURABILITY
};

/* reads a t_delete object */
static gint32
t_delete_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TDelete * this_object = T_DELETE(object);
  gboolean isset_row = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TColumn * _elem17 = NULL;
              if ( _elem17 != NULL)
              {
                g_object_unref (_elem17);
              }
              _elem17 = g_object_new (TYPE_T_COLUMN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem17), protocol, error)) < 0)
              {
                g_object_unref (_elem17);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->columns, _elem17);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          gint32 ecast18;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast18, error)) < 0)
            return -1;
          xfer += ret;
          this_object->deleteType = (TDeleteType)ecast18;
          this_object->__isset_deleteType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GByteArray * key19 = NULL;
              GByteArray * val20 = NULL;
              if (key19 != NULL)
              {
                g_free(key19);
                key19 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key19 = g_byte_array_new();
              g_byte_array_append (key19, (guint8 *) data, (guint) len);
              g_free (data);
              if (val20 != NULL)
              {
                g_free(val20);
                val20 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val20 = g_byte_array_new();
              g_byte_array_append (val20, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key19)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key19, (gpointer) val20);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          gint32 ecast21;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast21, error)) < 0)
            return -1;
          xfer += ret;
          this_object->durability = (TDurability)ecast21;
          this_object->__isset_durability = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_row)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_delete_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TDelete * this_object = T_DELETE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TDelete", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_columns == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i22;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i22 = 0; i22 < (this_object->columns ? this_object->columns->len : 0); i22++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->columns, i22))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_timestamp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_deleteType == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "deleteType", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->deleteType, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_attributes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 6, error)) < 0)
      return -1;
    xfer += ret;
    {
      GByteArray * key23 = NULL;
      GByteArray * val24 = NULL;
      GList *key_list = NULL, *iter = NULL;
      GByteArray ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->attributes)
        g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (GByteArray *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (GByteArray *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key23 = keys[i];
        val24 = (GByteArray *) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key23);

        if ((ret = thrift_protocol_write_binary (protocol,  key23 ? ((GByteArray *)  key23)->data : NULL,  key23 ? ((GByteArray *)  key23)->len : 0, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val24 ? ((GByteArray *)  val24)->data : NULL,  val24 ? ((GByteArray *)  val24)->len : 0, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_durability == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "durability", T_I32, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->durability, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_delete_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  TDelete *self = T_DELETE (object);

  switch (property_id)
  {
    case PROP_T_DELETE_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      break;

    case PROP_T_DELETE_COLUMNS:
      if (self->columns != NULL)
        g_ptr_array_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      self->__isset_columns = TRUE;
      break;

    case PROP_T_DELETE_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_T_DELETE_DELETE_TYPE:
      self->deleteType = g_value_get_int (value);
      self->__isset_deleteType = TRUE;
      break;

    case PROP_T_DELETE_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    case PROP_T_DELETE_DURABILITY:
      self->durability = g_value_get_int (value);
      self->__isset_durability = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_delete_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  TDelete *self = T_DELETE (object);

  switch (property_id)
  {
    case PROP_T_DELETE_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_T_DELETE_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_T_DELETE_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    case PROP_T_DELETE_DELETE_TYPE:
      g_value_set_int (value, self->deleteType);
      break;

    case PROP_T_DELETE_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    case PROP_T_DELETE_DURABILITY:
      g_value_set_int (value, self->durability);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_delete_instance_init (TDelete * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->row = NULL;
  object->columns = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_columns = FALSE;
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
  object->__isset_deleteType = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
  object->__isset_durability = FALSE;
}

static void 
t_delete_finalize (GObject *object)
{
  TDelete *tobject = T_DELETE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
t_delete_class_init (TDeleteClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_delete_read;
  struct_class->write = t_delete_write;

  gobject_class->finalize = t_delete_finalize;
  gobject_class->get_property = t_delete_get_property;
  gobject_class->set_property = t_delete_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_DELETE_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_DELETE_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_DELETE_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_DELETE_DELETE_TYPE,
     g_param_spec_int ("deleteType",
                       NULL,
                       NULL,
                       0,
                       1,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_DELETE_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_DELETE_DURABILITY,
     g_param_spec_int ("durability",
                       NULL,
                       NULL,
                       1,
                       4,
                       1,
                       G_PARAM_READWRITE));
}

GType
t_delete_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TDeleteClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_delete_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TDelete),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_delete_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TDeleteType",
                                   &type_info, 0);
  }

  return type;
}

enum _TIncrementProperties
{
  PROP_T_INCREMENT_0,
  PROP_T_INCREMENT_ROW,
  PROP_T_INCREMENT_COLUMNS,
  PROP_T_INCREMENT_ATTRIBUTES,
  PROP_T_INCREMENT_DURABILITY,
  PROP_T_INCREMENT_CELL_VISIBILITY
};

/* reads a t_increment object */
static gint32
t_increment_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TIncrement * this_object = T_INCREMENT(object);
  gboolean isset_row = FALSE;
  gboolean isset_columns = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TColumnIncrement * _elem25 = NULL;
              if ( _elem25 != NULL)
              {
                g_object_unref (_elem25);
              }
              _elem25 = g_object_new (TYPE_T_COLUMN_INCREMENT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem25), protocol, error)) < 0)
              {
                g_object_unref (_elem25);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->columns, _elem25);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GByteArray * key26 = NULL;
              GByteArray * val27 = NULL;
              if (key26 != NULL)
              {
                g_free(key26);
                key26 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key26 = g_byte_array_new();
              g_byte_array_append (key26, (guint8 *) data, (guint) len);
              g_free (data);
              if (val27 != NULL)
              {
                g_free(val27);
                val27 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val27 = g_byte_array_new();
              g_byte_array_append (val27, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key26)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key26, (gpointer) val27);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          gint32 ecast28;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast28, error)) < 0)
            return -1;
          xfer += ret;
          this_object->durability = (TDurability)ecast28;
          this_object->__isset_durability = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->cellVisibility), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_cellVisibility = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_row)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_columns)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_increment_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TIncrement * this_object = T_INCREMENT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TIncrement", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i29;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i29 = 0; i29 < (this_object->columns ? this_object->columns->len : 0); i29++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->columns, i29))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_attributes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      GByteArray * key30 = NULL;
      GByteArray * val31 = NULL;
      GList *key_list = NULL, *iter = NULL;
      GByteArray ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->attributes)
        g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (GByteArray *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (GByteArray *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key30 = keys[i];
        val31 = (GByteArray *) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key30);

        if ((ret = thrift_protocol_write_binary (protocol,  key30 ? ((GByteArray *)  key30)->data : NULL,  key30 ? ((GByteArray *)  key30)->len : 0, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val31 ? ((GByteArray *)  val31)->data : NULL,  val31 ? ((GByteArray *)  val31)->len : 0, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_durability == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "durability", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->durability, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_cellVisibility == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cellVisibility", T_STRUCT, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->cellVisibility), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_increment_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  TIncrement *self = T_INCREMENT (object);

  switch (property_id)
  {
    case PROP_T_INCREMENT_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      break;

    case PROP_T_INCREMENT_COLUMNS:
      if (self->columns != NULL)
        g_ptr_array_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      break;

    case PROP_T_INCREMENT_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    case PROP_T_INCREMENT_DURABILITY:
      self->durability = g_value_get_int (value);
      self->__isset_durability = TRUE;
      break;

    case PROP_T_INCREMENT_CELL_VISIBILITY:
      if (self->cellVisibility != NULL)
        g_object_unref (self->cellVisibility);
      self->cellVisibility = g_value_dup_object (value);
      self->__isset_cellVisibility = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_increment_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  TIncrement *self = T_INCREMENT (object);

  switch (property_id)
  {
    case PROP_T_INCREMENT_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_T_INCREMENT_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_T_INCREMENT_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    case PROP_T_INCREMENT_DURABILITY:
      g_value_set_int (value, self->durability);
      break;

    case PROP_T_INCREMENT_CELL_VISIBILITY:
      g_value_set_object (value, self->cellVisibility);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_increment_instance_init (TIncrement * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->row = NULL;
  object->columns = g_ptr_array_new_with_free_func (g_object_unref);
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
  object->__isset_durability = FALSE;
  object->cellVisibility = g_object_new (TYPE_T_CELL_VISIBILITY, NULL);
  object->__isset_cellVisibility = FALSE;
}

static void 
t_increment_finalize (GObject *object)
{
  TIncrement *tobject = T_INCREMENT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
  if (tobject->cellVisibility != NULL)
  {
    g_object_unref(tobject->cellVisibility);
    tobject->cellVisibility = NULL;
  }
}

static void
t_increment_class_init (TIncrementClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_increment_read;
  struct_class->write = t_increment_write;

  gobject_class->finalize = t_increment_finalize;
  gobject_class->get_property = t_increment_get_property;
  gobject_class->set_property = t_increment_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_INCREMENT_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_INCREMENT_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_INCREMENT_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_INCREMENT_DURABILITY,
     g_param_spec_int ("durability",
                       NULL,
                       NULL,
                       1,
                       4,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_INCREMENT_CELL_VISIBILITY,
     g_param_spec_object ("cellVisibility",
                         NULL,
                         NULL,
                         TYPE_T_CELL_VISIBILITY,
                         G_PARAM_READWRITE));
}

GType
t_increment_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TIncrementClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_increment_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TIncrement),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_increment_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TIncrementType",
                                   &type_info, 0);
  }

  return type;
}

enum _TAppendProperties
{
  PROP_T_APPEND_0,
  PROP_T_APPEND_ROW,
  PROP_T_APPEND_COLUMNS,
  PROP_T_APPEND_ATTRIBUTES,
  PROP_T_APPEND_DURABILITY,
  PROP_T_APPEND_CELL_VISIBILITY
};

/* reads a t_append object */
static gint32
t_append_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TAppend * this_object = T_APPEND(object);
  gboolean isset_row = FALSE;
  gboolean isset_columns = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TColumnValue * _elem32 = NULL;
              if ( _elem32 != NULL)
              {
                g_object_unref (_elem32);
              }
              _elem32 = g_object_new (TYPE_T_COLUMN_VALUE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem32), protocol, error)) < 0)
              {
                g_object_unref (_elem32);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->columns, _elem32);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GByteArray * key33 = NULL;
              GByteArray * val34 = NULL;
              if (key33 != NULL)
              {
                g_free(key33);
                key33 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key33 = g_byte_array_new();
              g_byte_array_append (key33, (guint8 *) data, (guint) len);
              g_free (data);
              if (val34 != NULL)
              {
                g_free(val34);
                val34 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val34 = g_byte_array_new();
              g_byte_array_append (val34, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key33)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key33, (gpointer) val34);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          gint32 ecast35;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast35, error)) < 0)
            return -1;
          xfer += ret;
          this_object->durability = (TDurability)ecast35;
          this_object->__isset_durability = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->cellVisibility), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_cellVisibility = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_row)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_columns)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_append_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TAppend * this_object = T_APPEND(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TAppend", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i36;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i36 = 0; i36 < (this_object->columns ? this_object->columns->len : 0); i36++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->columns, i36))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_attributes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      GByteArray * key37 = NULL;
      GByteArray * val38 = NULL;
      GList *key_list = NULL, *iter = NULL;
      GByteArray ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->attributes)
        g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (GByteArray *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (GByteArray *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key37 = keys[i];
        val38 = (GByteArray *) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key37);

        if ((ret = thrift_protocol_write_binary (protocol,  key37 ? ((GByteArray *)  key37)->data : NULL,  key37 ? ((GByteArray *)  key37)->len : 0, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val38 ? ((GByteArray *)  val38)->data : NULL,  val38 ? ((GByteArray *)  val38)->len : 0, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_durability == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "durability", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->durability, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_cellVisibility == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cellVisibility", T_STRUCT, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->cellVisibility), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_append_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  TAppend *self = T_APPEND (object);

  switch (property_id)
  {
    case PROP_T_APPEND_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      break;

    case PROP_T_APPEND_COLUMNS:
      if (self->columns != NULL)
        g_ptr_array_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      break;

    case PROP_T_APPEND_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    case PROP_T_APPEND_DURABILITY:
      self->durability = g_value_get_int (value);
      self->__isset_durability = TRUE;
      break;

    case PROP_T_APPEND_CELL_VISIBILITY:
      if (self->cellVisibility != NULL)
        g_object_unref (self->cellVisibility);
      self->cellVisibility = g_value_dup_object (value);
      self->__isset_cellVisibility = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_append_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  TAppend *self = T_APPEND (object);

  switch (property_id)
  {
    case PROP_T_APPEND_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_T_APPEND_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_T_APPEND_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    case PROP_T_APPEND_DURABILITY:
      g_value_set_int (value, self->durability);
      break;

    case PROP_T_APPEND_CELL_VISIBILITY:
      g_value_set_object (value, self->cellVisibility);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_append_instance_init (TAppend * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->row = NULL;
  object->columns = g_ptr_array_new_with_free_func (g_object_unref);
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
  object->__isset_durability = FALSE;
  object->cellVisibility = g_object_new (TYPE_T_CELL_VISIBILITY, NULL);
  object->__isset_cellVisibility = FALSE;
}

static void 
t_append_finalize (GObject *object)
{
  TAppend *tobject = T_APPEND (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
  if (tobject->cellVisibility != NULL)
  {
    g_object_unref(tobject->cellVisibility);
    tobject->cellVisibility = NULL;
  }
}

static void
t_append_class_init (TAppendClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_append_read;
  struct_class->write = t_append_write;

  gobject_class->finalize = t_append_finalize;
  gobject_class->get_property = t_append_get_property;
  gobject_class->set_property = t_append_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_APPEND_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_APPEND_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_APPEND_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_APPEND_DURABILITY,
     g_param_spec_int ("durability",
                       NULL,
                       NULL,
                       1,
                       4,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_APPEND_CELL_VISIBILITY,
     g_param_spec_object ("cellVisibility",
                         NULL,
                         NULL,
                         TYPE_T_CELL_VISIBILITY,
                         G_PARAM_READWRITE));
}

GType
t_append_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TAppendClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_append_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TAppend),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_append_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TAppendType",
                                   &type_info, 0);
  }

  return type;
}

enum _TScanProperties
{
  PROP_T_SCAN_0,
  PROP_T_SCAN_START_ROW,
  PROP_T_SCAN_STOP_ROW,
  PROP_T_SCAN_COLUMNS,
  PROP_T_SCAN_CACHING,
  PROP_T_SCAN_MAX_VERSIONS,
  PROP_T_SCAN_TIME_RANGE,
  PROP_T_SCAN_FILTER_STRING,
  PROP_T_SCAN_BATCH_SIZE,
  PROP_T_SCAN_ATTRIBUTES,
  PROP_T_SCAN_AUTHORIZATIONS,
  PROP_T_SCAN_REVERSED,
  PROP_T_SCAN_CACHE_BLOCKS,
  PROP_T_SCAN_COL_FAM_TIME_RANGE_MAP,
  PROP_T_SCAN_SMALL
};

/* reads a t_scan object */
static gint32
t_scan_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TScan * this_object = T_SCAN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->startRow != NULL)
          {
            g_free(this_object->startRow);
            this_object->startRow = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->startRow = g_byte_array_new();
          g_byte_array_append (this_object->startRow, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_startRow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->stopRow != NULL)
          {
            g_free(this_object->stopRow);
            this_object->stopRow = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->stopRow = g_byte_array_new();
          g_byte_array_append (this_object->stopRow, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_stopRow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TColumn * _elem39 = NULL;
              if ( _elem39 != NULL)
              {
                g_object_unref (_elem39);
              }
              _elem39 = g_object_new (TYPE_T_COLUMN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem39), protocol, error)) < 0)
              {
                g_object_unref (_elem39);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->columns, _elem39);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->caching, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_caching = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->maxVersions, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_maxVersions = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->timeRange), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_timeRange = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->filterString != NULL)
          {
            g_free(this_object->filterString);
            this_object->filterString = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->filterString = g_byte_array_new();
          g_byte_array_append (this_object->filterString, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_filterString = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->batchSize, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_batchSize = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GByteArray * key40 = NULL;
              GByteArray * val41 = NULL;
              if (key40 != NULL)
              {
                g_free(key40);
                key40 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key40 = g_byte_array_new();
              g_byte_array_append (key40, (guint8 *) data, (guint) len);
              g_free (data);
              if (val41 != NULL)
              {
                g_free(val41);
                val41 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val41 = g_byte_array_new();
              g_byte_array_append (val41, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key40)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key40, (gpointer) val41);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->authorizations), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_authorizations = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->reversed, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_reversed = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->cacheBlocks, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cacheBlocks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GByteArray * key42 = NULL;
              TTimeRange * val43 = NULL;
              if (key42 != NULL)
              {
                g_free(key42);
                key42 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key42 = g_byte_array_new();
              g_byte_array_append (key42, (guint8 *) data, (guint) len);
              g_free (data);
              if ( val43 != NULL)
              {
                g_object_unref (val43);
              }
              val43 = g_object_new (TYPE_T_TIME_RANGE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val43), protocol, error)) < 0)
              {
                g_object_unref (val43);
                return -1;
              }
              xfer += ret;
              if (this_object->colFamTimeRangeMap && key42)
                g_hash_table_insert ((GHashTable *)this_object->colFamTimeRangeMap, (gpointer) key42, (gpointer) val43);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_colFamTimeRangeMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->small, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_small = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_scan_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TScan * this_object = T_SCAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TScan", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_startRow == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->startRow ? ((GByteArray *) this_object->startRow)->data : NULL, this_object->startRow ? ((GByteArray *) this_object->startRow)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_stopRow == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "stopRow", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->stopRow ? ((GByteArray *) this_object->stopRow)->data : NULL, this_object->stopRow ? ((GByteArray *) this_object->stopRow)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_columns == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i44;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i44 = 0; i44 < (this_object->columns ? this_object->columns->len : 0); i44++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->columns, i44))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_caching == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "caching", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->caching, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_maxVersions == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "maxVersions", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->maxVersions, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_timeRange == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "timeRange", T_STRUCT, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->timeRange), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_filterString == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "filterString", T_STRING, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->filterString ? ((GByteArray *) this_object->filterString)->data : NULL, this_object->filterString ? ((GByteArray *) this_object->filterString)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_batchSize == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "batchSize", T_I32, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->batchSize, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_attributes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 9, error)) < 0)
      return -1;
    xfer += ret;
    {
      GByteArray * key45 = NULL;
      GByteArray * val46 = NULL;
      GList *key_list = NULL, *iter = NULL;
      GByteArray ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->attributes)
        g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (GByteArray *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (GByteArray *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key45 = keys[i];
        val46 = (GByteArray *) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key45);

        if ((ret = thrift_protocol_write_binary (protocol,  key45 ? ((GByteArray *)  key45)->data : NULL,  key45 ? ((GByteArray *)  key45)->len : 0, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val46 ? ((GByteArray *)  val46)->data : NULL,  val46 ? ((GByteArray *)  val46)->len : 0, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_authorizations == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "authorizations", T_STRUCT, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->authorizations), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_reversed == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "reversed", T_BOOL, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->reversed, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_cacheBlocks == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cacheBlocks", T_BOOL, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->cacheBlocks, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_colFamTimeRangeMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "colFamTimeRangeMap", T_MAP, 13, error)) < 0)
      return -1;
    xfer += ret;
    {
      GByteArray * key47 = NULL;
      TTimeRange * val48 = NULL;
      GList *key_list = NULL, *iter = NULL;
      GByteArray ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRUCT, this_object->colFamTimeRangeMap ? (gint32) g_hash_table_size ((GHashTable *) this_object->colFamTimeRangeMap) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->colFamTimeRangeMap)
        g_hash_table_foreach ((GHashTable *) this_object->colFamTimeRangeMap, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (GByteArray *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (GByteArray *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key47 = keys[i];
        val48 = (TTimeRange *) g_hash_table_lookup (((GHashTable *) this_object->colFamTimeRangeMap), (gpointer) key47);

        if ((ret = thrift_protocol_write_binary (protocol,  key47 ? ((GByteArray *)  key47)->data : NULL,  key47 ? ((GByteArray *)  key47)->len : 0, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_struct_write (THRIFT_STRUCT ( val48), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_small == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "small", T_BOOL, 14, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->small, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_scan_set_property (GObject *object,
                     guint property_id,
                     const GValue *value,
                     GParamSpec *pspec)
{
  TScan *self = T_SCAN (object);

  switch (property_id)
  {
    case PROP_T_SCAN_START_ROW:
      if (self->startRow != NULL)
        g_byte_array_unref (self->startRow);
      self->startRow = g_value_dup_boxed (value);
      self->__isset_startRow = TRUE;
      break;

    case PROP_T_SCAN_STOP_ROW:
      if (self->stopRow != NULL)
        g_byte_array_unref (self->stopRow);
      self->stopRow = g_value_dup_boxed (value);
      self->__isset_stopRow = TRUE;
      break;

    case PROP_T_SCAN_COLUMNS:
      if (self->columns != NULL)
        g_ptr_array_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      self->__isset_columns = TRUE;
      break;

    case PROP_T_SCAN_CACHING:
      self->caching = g_value_get_int (value);
      self->__isset_caching = TRUE;
      break;

    case PROP_T_SCAN_MAX_VERSIONS:
      self->maxVersions = g_value_get_int (value);
      self->__isset_maxVersions = TRUE;
      break;

    case PROP_T_SCAN_TIME_RANGE:
      if (self->timeRange != NULL)
        g_object_unref (self->timeRange);
      self->timeRange = g_value_dup_object (value);
      self->__isset_timeRange = TRUE;
      break;

    case PROP_T_SCAN_FILTER_STRING:
      if (self->filterString != NULL)
        g_byte_array_unref (self->filterString);
      self->filterString = g_value_dup_boxed (value);
      self->__isset_filterString = TRUE;
      break;

    case PROP_T_SCAN_BATCH_SIZE:
      self->batchSize = g_value_get_int (value);
      self->__isset_batchSize = TRUE;
      break;

    case PROP_T_SCAN_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    case PROP_T_SCAN_AUTHORIZATIONS:
      if (self->authorizations != NULL)
        g_object_unref (self->authorizations);
      self->authorizations = g_value_dup_object (value);
      self->__isset_authorizations = TRUE;
      break;

    case PROP_T_SCAN_REVERSED:
      self->reversed = g_value_get_boolean (value);
      self->__isset_reversed = TRUE;
      break;

    case PROP_T_SCAN_CACHE_BLOCKS:
      self->cacheBlocks = g_value_get_boolean (value);
      self->__isset_cacheBlocks = TRUE;
      break;

    case PROP_T_SCAN_COL_FAM_TIME_RANGE_MAP:
      if (self->colFamTimeRangeMap != NULL)
        g_hash_table_unref (self->colFamTimeRangeMap);
      self->colFamTimeRangeMap = g_value_dup_boxed (value);
      self->__isset_colFamTimeRangeMap = TRUE;
      break;

    case PROP_T_SCAN_SMALL:
      self->small = g_value_get_boolean (value);
      self->__isset_small = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_scan_get_property (GObject *object,
                     guint property_id,
                     GValue *value,
                     GParamSpec *pspec)
{
  TScan *self = T_SCAN (object);

  switch (property_id)
  {
    case PROP_T_SCAN_START_ROW:
      g_value_set_boxed (value, self->startRow);
      break;

    case PROP_T_SCAN_STOP_ROW:
      g_value_set_boxed (value, self->stopRow);
      break;

    case PROP_T_SCAN_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_T_SCAN_CACHING:
      g_value_set_int (value, self->caching);
      break;

    case PROP_T_SCAN_MAX_VERSIONS:
      g_value_set_int (value, self->maxVersions);
      break;

    case PROP_T_SCAN_TIME_RANGE:
      g_value_set_object (value, self->timeRange);
      break;

    case PROP_T_SCAN_FILTER_STRING:
      g_value_set_boxed (value, self->filterString);
      break;

    case PROP_T_SCAN_BATCH_SIZE:
      g_value_set_int (value, self->batchSize);
      break;

    case PROP_T_SCAN_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    case PROP_T_SCAN_AUTHORIZATIONS:
      g_value_set_object (value, self->authorizations);
      break;

    case PROP_T_SCAN_REVERSED:
      g_value_set_boolean (value, self->reversed);
      break;

    case PROP_T_SCAN_CACHE_BLOCKS:
      g_value_set_boolean (value, self->cacheBlocks);
      break;

    case PROP_T_SCAN_COL_FAM_TIME_RANGE_MAP:
      g_value_set_boxed (value, self->colFamTimeRangeMap);
      break;

    case PROP_T_SCAN_SMALL:
      g_value_set_boolean (value, self->small);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_scan_instance_init (TScan * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->startRow = NULL;
  object->__isset_startRow = FALSE;
  object->stopRow = NULL;
  object->__isset_stopRow = FALSE;
  object->columns = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_columns = FALSE;
  object->caching = 0;
  object->__isset_caching = FALSE;
  object->maxVersions = 1;
  object->__isset_maxVersions = FALSE;
  object->timeRange = g_object_new (TYPE_T_TIME_RANGE, NULL);
  object->__isset_timeRange = FALSE;
  object->filterString = NULL;
  object->__isset_filterString = FALSE;
  object->batchSize = 0;
  object->__isset_batchSize = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
  object->authorizations = g_object_new (TYPE_T_AUTHORIZATION, NULL);
  object->__isset_authorizations = FALSE;
  object->reversed = 0;
  object->__isset_reversed = FALSE;
  object->cacheBlocks = 0;
  object->__isset_cacheBlocks = FALSE;
  object->colFamTimeRangeMap = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, g_object_unref);
  object->__isset_colFamTimeRangeMap = FALSE;
  object->small = 0;
  object->__isset_small = FALSE;
}

static void 
t_scan_finalize (GObject *object)
{
  TScan *tobject = T_SCAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->startRow != NULL)
  {
    thrift_string_free(tobject->startRow);
    tobject->startRow = NULL;
  }
  if (tobject->stopRow != NULL)
  {
    thrift_string_free(tobject->stopRow);
    tobject->stopRow = NULL;
  }
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->timeRange != NULL)
  {
    g_object_unref(tobject->timeRange);
    tobject->timeRange = NULL;
  }
  if (tobject->filterString != NULL)
  {
    thrift_string_free(tobject->filterString);
    tobject->filterString = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
  if (tobject->authorizations != NULL)
  {
    g_object_unref(tobject->authorizations);
    tobject->authorizations = NULL;
  }
  if (tobject->colFamTimeRangeMap != NULL)
  {
    g_hash_table_destroy (tobject->colFamTimeRangeMap);
    tobject->colFamTimeRangeMap = NULL;
  }
}

static void
t_scan_class_init (TScanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_scan_read;
  struct_class->write = t_scan_write;

  gobject_class->finalize = t_scan_finalize;
  gobject_class->get_property = t_scan_get_property;
  gobject_class->set_property = t_scan_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_START_ROW,
     g_param_spec_boxed ("startRow",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_STOP_ROW,
     g_param_spec_boxed ("stopRow",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_CACHING,
     g_param_spec_int ("caching",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_MAX_VERSIONS,
     g_param_spec_int ("maxVersions",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_TIME_RANGE,
     g_param_spec_object ("timeRange",
                         NULL,
                         NULL,
                         TYPE_T_TIME_RANGE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_FILTER_STRING,
     g_param_spec_boxed ("filterString",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_BATCH_SIZE,
     g_param_spec_int ("batchSize",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_AUTHORIZATIONS,
     g_param_spec_object ("authorizations",
                         NULL,
                         NULL,
                         TYPE_T_AUTHORIZATION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_REVERSED,
     g_param_spec_boolean ("reversed",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_CACHE_BLOCKS,
     g_param_spec_boolean ("cacheBlocks",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_COL_FAM_TIME_RANGE_MAP,
     g_param_spec_boxed ("colFamTimeRangeMap",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_SMALL,
     g_param_spec_boolean ("small",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
t_scan_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TScanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_scan_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TScan),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_scan_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TScanType",
                                   &type_info, 0);
  }

  return type;
}

enum _TMutationProperties
{
  PROP_T_MUTATION_0,
  PROP_T_MUTATION_PUT,
  PROP_T_MUTATION_DELETE_SINGLE
};

/* reads a t_mutation object */
static gint32
t_mutation_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TMutation * this_object = T_MUTATION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->put), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_put = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->deleteSingle), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_deleteSingle = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_mutation_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TMutation * this_object = T_MUTATION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TMutation", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_put == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "put", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->put), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_deleteSingle == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "deleteSingle", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->deleteSingle), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_mutation_set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  TMutation *self = T_MUTATION (object);

  switch (property_id)
  {
    case PROP_T_MUTATION_PUT:
      if (self->put != NULL)
        g_object_unref (self->put);
      self->put = g_value_dup_object (value);
      self->__isset_put = TRUE;
      break;

    case PROP_T_MUTATION_DELETE_SINGLE:
      if (self->deleteSingle != NULL)
        g_object_unref (self->deleteSingle);
      self->deleteSingle = g_value_dup_object (value);
      self->__isset_deleteSingle = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_mutation_get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  TMutation *self = T_MUTATION (object);

  switch (property_id)
  {
    case PROP_T_MUTATION_PUT:
      g_value_set_object (value, self->put);
      break;

    case PROP_T_MUTATION_DELETE_SINGLE:
      g_value_set_object (value, self->deleteSingle);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_mutation_instance_init (TMutation * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->put = g_object_new (TYPE_T_PUT, NULL);
  object->__isset_put = FALSE;
  object->deleteSingle = g_object_new (TYPE_T_DELETE, NULL);
  object->__isset_deleteSingle = FALSE;
}

static void 
t_mutation_finalize (GObject *object)
{
  TMutation *tobject = T_MUTATION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->put != NULL)
  {
    g_object_unref(tobject->put);
    tobject->put = NULL;
  }
  if (tobject->deleteSingle != NULL)
  {
    g_object_unref(tobject->deleteSingle);
    tobject->deleteSingle = NULL;
  }
}

static void
t_mutation_class_init (TMutationClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_mutation_read;
  struct_class->write = t_mutation_write;

  gobject_class->finalize = t_mutation_finalize;
  gobject_class->get_property = t_mutation_get_property;
  gobject_class->set_property = t_mutation_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_MUTATION_PUT,
     g_param_spec_object ("put",
                         NULL,
                         NULL,
                         TYPE_T_PUT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_MUTATION_DELETE_SINGLE,
     g_param_spec_object ("deleteSingle",
                         NULL,
                         NULL,
                         TYPE_T_DELETE,
                         G_PARAM_READWRITE));
}

GType
t_mutation_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TMutationClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_mutation_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TMutation),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_mutation_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TMutationType",
                                   &type_info, 0);
  }

  return type;
}

enum _TRowMutationsProperties
{
  PROP_T_ROW_MUTATIONS_0,
  PROP_T_ROW_MUTATIONS_ROW,
  PROP_T_ROW_MUTATIONS_MUTATIONS
};

/* reads a t_row_mutations object */
static gint32
t_row_mutations_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TRowMutations * this_object = T_ROW_MUTATIONS(object);
  gboolean isset_row = FALSE;
  gboolean isset_mutations = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TMutation * _elem49 = NULL;
              if ( _elem49 != NULL)
              {
                g_object_unref (_elem49);
              }
              _elem49 = g_object_new (TYPE_T_MUTATION, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem49), protocol, error)) < 0)
              {
                g_object_unref (_elem49);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->mutations, _elem49);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_mutations = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_row)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_mutations)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_row_mutations_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TRowMutations * this_object = T_ROW_MUTATIONS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TRowMutations", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mutations", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i50;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->mutations ? this_object->mutations->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i50 = 0; i50 < (this_object->mutations ? this_object->mutations->len : 0); i50++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->mutations, i50))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_row_mutations_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  TRowMutations *self = T_ROW_MUTATIONS (object);

  switch (property_id)
  {
    case PROP_T_ROW_MUTATIONS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      break;

    case PROP_T_ROW_MUTATIONS_MUTATIONS:
      if (self->mutations != NULL)
        g_ptr_array_unref (self->mutations);
      self->mutations = g_value_dup_boxed (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_row_mutations_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  TRowMutations *self = T_ROW_MUTATIONS (object);

  switch (property_id)
  {
    case PROP_T_ROW_MUTATIONS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_T_ROW_MUTATIONS_MUTATIONS:
      g_value_set_boxed (value, self->mutations);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_row_mutations_instance_init (TRowMutations * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->row = NULL;
  object->mutations = g_ptr_array_new_with_free_func (g_object_unref);
}

static void 
t_row_mutations_finalize (GObject *object)
{
  TRowMutations *tobject = T_ROW_MUTATIONS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->mutations != NULL)
  {
    g_ptr_array_unref (tobject->mutations);
    tobject->mutations = NULL;
  }
}

static void
t_row_mutations_class_init (TRowMutationsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_row_mutations_read;
  struct_class->write = t_row_mutations_write;

  gobject_class->finalize = t_row_mutations_finalize;
  gobject_class->get_property = t_row_mutations_get_property;
  gobject_class->set_property = t_row_mutations_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_ROW_MUTATIONS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_ROW_MUTATIONS_MUTATIONS,
     g_param_spec_boxed ("mutations",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_row_mutations_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TRowMutationsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_row_mutations_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TRowMutations),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_row_mutations_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TRowMutationsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THRegionInfoProperties
{
  PROP_T_H_REGION_INFO_0,
  PROP_T_H_REGION_INFO_REGION_ID,
  PROP_T_H_REGION_INFO_TABLE_NAME,
  PROP_T_H_REGION_INFO_START_KEY,
  PROP_T_H_REGION_INFO_END_KEY,
  PROP_T_H_REGION_INFO_OFFLINE,
  PROP_T_H_REGION_INFO_SPLIT,
  PROP_T_H_REGION_INFO_REPLICA_ID
};

/* reads a t_h_region_info object */
static gint32
t_h_region_info_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THRegionInfo * this_object = T_H_REGION_INFO(object);
  gboolean isset_regionId = FALSE;
  gboolean isset_tableName = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->regionId, error)) < 0)
            return -1;
          xfer += ret;
          isset_regionId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->startKey != NULL)
          {
            g_free(this_object->startKey);
            this_object->startKey = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->startKey = g_byte_array_new();
          g_byte_array_append (this_object->startKey, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_startKey = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->endKey != NULL)
          {
            g_free(this_object->endKey);
            this_object->endKey = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->endKey = g_byte_array_new();
          g_byte_array_append (this_object->endKey, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_endKey = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->offline, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_offline = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->split, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_split = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->replicaId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_replicaId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_regionId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_tableName)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_region_info_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THRegionInfo * this_object = T_H_REGION_INFO(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THRegionInfo", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "regionId", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->regionId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_startKey == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "startKey", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->startKey ? ((GByteArray *) this_object->startKey)->data : NULL, this_object->startKey ? ((GByteArray *) this_object->startKey)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_endKey == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "endKey", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->endKey ? ((GByteArray *) this_object->endKey)->data : NULL, this_object->endKey ? ((GByteArray *) this_object->endKey)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_offline == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "offline", T_BOOL, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->offline, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_split == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "split", T_BOOL, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->split, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_replicaId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "replicaId", T_I32, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->replicaId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_region_info_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  THRegionInfo *self = T_H_REGION_INFO (object);

  switch (property_id)
  {
    case PROP_T_H_REGION_INFO_REGION_ID:
      self->regionId = g_value_get_int64 (value);
      break;

    case PROP_T_H_REGION_INFO_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      break;

    case PROP_T_H_REGION_INFO_START_KEY:
      if (self->startKey != NULL)
        g_byte_array_unref (self->startKey);
      self->startKey = g_value_dup_boxed (value);
      self->__isset_startKey = TRUE;
      break;

    case PROP_T_H_REGION_INFO_END_KEY:
      if (self->endKey != NULL)
        g_byte_array_unref (self->endKey);
      self->endKey = g_value_dup_boxed (value);
      self->__isset_endKey = TRUE;
      break;

    case PROP_T_H_REGION_INFO_OFFLINE:
      self->offline = g_value_get_boolean (value);
      self->__isset_offline = TRUE;
      break;

    case PROP_T_H_REGION_INFO_SPLIT:
      self->split = g_value_get_boolean (value);
      self->__isset_split = TRUE;
      break;

    case PROP_T_H_REGION_INFO_REPLICA_ID:
      self->replicaId = g_value_get_int (value);
      self->__isset_replicaId = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_region_info_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  THRegionInfo *self = T_H_REGION_INFO (object);

  switch (property_id)
  {
    case PROP_T_H_REGION_INFO_REGION_ID:
      g_value_set_int64 (value, self->regionId);
      break;

    case PROP_T_H_REGION_INFO_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_T_H_REGION_INFO_START_KEY:
      g_value_set_boxed (value, self->startKey);
      break;

    case PROP_T_H_REGION_INFO_END_KEY:
      g_value_set_boxed (value, self->endKey);
      break;

    case PROP_T_H_REGION_INFO_OFFLINE:
      g_value_set_boolean (value, self->offline);
      break;

    case PROP_T_H_REGION_INFO_SPLIT:
      g_value_set_boolean (value, self->split);
      break;

    case PROP_T_H_REGION_INFO_REPLICA_ID:
      g_value_set_int (value, self->replicaId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_region_info_instance_init (THRegionInfo * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->regionId = 0;
  object->tableName = NULL;
  object->startKey = NULL;
  object->__isset_startKey = FALSE;
  object->endKey = NULL;
  object->__isset_endKey = FALSE;
  object->offline = 0;
  object->__isset_offline = FALSE;
  object->split = 0;
  object->__isset_split = FALSE;
  object->replicaId = 0;
  object->__isset_replicaId = FALSE;
}

static void 
t_h_region_info_finalize (GObject *object)
{
  THRegionInfo *tobject = T_H_REGION_INFO (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->startKey != NULL)
  {
    thrift_string_free(tobject->startKey);
    tobject->startKey = NULL;
  }
  if (tobject->endKey != NULL)
  {
    thrift_string_free(tobject->endKey);
    tobject->endKey = NULL;
  }
}

static void
t_h_region_info_class_init (THRegionInfoClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_region_info_read;
  struct_class->write = t_h_region_info_write;

  gobject_class->finalize = t_h_region_info_finalize;
  gobject_class->get_property = t_h_region_info_get_property;
  gobject_class->set_property = t_h_region_info_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_REGION_INFO_REGION_ID,
     g_param_spec_int64 ("regionId",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_REGION_INFO_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_REGION_INFO_START_KEY,
     g_param_spec_boxed ("startKey",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_REGION_INFO_END_KEY,
     g_param_spec_boxed ("endKey",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_REGION_INFO_OFFLINE,
     g_param_spec_boolean ("offline",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_REGION_INFO_SPLIT,
     g_param_spec_boolean ("split",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_REGION_INFO_REPLICA_ID,
     g_param_spec_int ("replicaId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_h_region_info_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THRegionInfoClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_region_info_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THRegionInfo),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_region_info_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THRegionInfoType",
                                   &type_info, 0);
  }

  return type;
}

enum _TServerNameProperties
{
  PROP_T_SERVER_NAME_0,
  PROP_T_SERVER_NAME_HOST_NAME,
  PROP_T_SERVER_NAME_PORT,
  PROP_T_SERVER_NAME_START_CODE
};

/* reads a t_server_name object */
static gint32
t_server_name_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TServerName * this_object = T_SERVER_NAME(object);
  gboolean isset_hostName = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->hostName != NULL)
          {
            g_free(this_object->hostName);
            this_object->hostName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->hostName, error)) < 0)
            return -1;
          xfer += ret;
          isset_hostName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->port, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_port = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->startCode, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_startCode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_hostName)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_server_name_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TServerName * this_object = T_SERVER_NAME(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TServerName", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "hostName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->hostName, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_port == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "port", T_I32, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->port, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_startCode == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "startCode", T_I64, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->startCode, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_server_name_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  TServerName *self = T_SERVER_NAME (object);

  switch (property_id)
  {
    case PROP_T_SERVER_NAME_HOST_NAME:
      if (self->hostName != NULL)
        g_free (self->hostName);
      self->hostName = g_value_dup_string (value);
      break;

    case PROP_T_SERVER_NAME_PORT:
      self->port = g_value_get_int (value);
      self->__isset_port = TRUE;
      break;

    case PROP_T_SERVER_NAME_START_CODE:
      self->startCode = g_value_get_int64 (value);
      self->__isset_startCode = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_server_name_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  TServerName *self = T_SERVER_NAME (object);

  switch (property_id)
  {
    case PROP_T_SERVER_NAME_HOST_NAME:
      g_value_set_string (value, self->hostName);
      break;

    case PROP_T_SERVER_NAME_PORT:
      g_value_set_int (value, self->port);
      break;

    case PROP_T_SERVER_NAME_START_CODE:
      g_value_set_int64 (value, self->startCode);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_server_name_instance_init (TServerName * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->hostName = NULL;
  object->port = 0;
  object->__isset_port = FALSE;
  object->startCode = 0;
  object->__isset_startCode = FALSE;
}

static void 
t_server_name_finalize (GObject *object)
{
  TServerName *tobject = T_SERVER_NAME (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->hostName != NULL)
  {
    g_free(tobject->hostName);
    tobject->hostName = NULL;
  }
}

static void
t_server_name_class_init (TServerNameClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_server_name_read;
  struct_class->write = t_server_name_write;

  gobject_class->finalize = t_server_name_finalize;
  gobject_class->get_property = t_server_name_get_property;
  gobject_class->set_property = t_server_name_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_SERVER_NAME_HOST_NAME,
     g_param_spec_string ("hostName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SERVER_NAME_PORT,
     g_param_spec_int ("port",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SERVER_NAME_START_CODE,
     g_param_spec_int64 ("startCode",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
t_server_name_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TServerNameClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_server_name_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TServerName),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_server_name_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TServerNameType",
                                   &type_info, 0);
  }

  return type;
}

enum _THRegionLocationProperties
{
  PROP_T_H_REGION_LOCATION_0,
  PROP_T_H_REGION_LOCATION_SERVER_NAME,
  PROP_T_H_REGION_LOCATION_REGION_INFO
};

/* reads a t_h_region_location object */
static gint32
t_h_region_location_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THRegionLocation * this_object = T_H_REGION_LOCATION(object);
  gboolean isset_serverName = FALSE;
  gboolean isset_regionInfo = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->serverName), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_serverName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->regionInfo), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_regionInfo = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_serverName)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_regionInfo)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_region_location_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THRegionLocation * this_object = T_H_REGION_LOCATION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THRegionLocation", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "serverName", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->serverName), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "regionInfo", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->regionInfo), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_region_location_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  THRegionLocation *self = T_H_REGION_LOCATION (object);

  switch (property_id)
  {
    case PROP_T_H_REGION_LOCATION_SERVER_NAME:
      if (self->serverName != NULL)
        g_object_unref (self->serverName);
      self->serverName = g_value_dup_object (value);
      break;

    case PROP_T_H_REGION_LOCATION_REGION_INFO:
      if (self->regionInfo != NULL)
        g_object_unref (self->regionInfo);
      self->regionInfo = g_value_dup_object (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_region_location_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  THRegionLocation *self = T_H_REGION_LOCATION (object);

  switch (property_id)
  {
    case PROP_T_H_REGION_LOCATION_SERVER_NAME:
      g_value_set_object (value, self->serverName);
      break;

    case PROP_T_H_REGION_LOCATION_REGION_INFO:
      g_value_set_object (value, self->regionInfo);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_region_location_instance_init (THRegionLocation * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->serverName = g_object_new (TYPE_T_SERVER_NAME, NULL);
  object->regionInfo = g_object_new (TYPE_T_H_REGION_INFO, NULL);
}

static void 
t_h_region_location_finalize (GObject *object)
{
  THRegionLocation *tobject = T_H_REGION_LOCATION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->serverName != NULL)
  {
    g_object_unref(tobject->serverName);
    tobject->serverName = NULL;
  }
  if (tobject->regionInfo != NULL)
  {
    g_object_unref(tobject->regionInfo);
    tobject->regionInfo = NULL;
  }
}

static void
t_h_region_location_class_init (THRegionLocationClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_region_location_read;
  struct_class->write = t_h_region_location_write;

  gobject_class->finalize = t_h_region_location_finalize;
  gobject_class->get_property = t_h_region_location_get_property;
  gobject_class->set_property = t_h_region_location_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_REGION_LOCATION_SERVER_NAME,
     g_param_spec_object ("serverName",
                         NULL,
                         NULL,
                         TYPE_T_SERVER_NAME,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_REGION_LOCATION_REGION_INFO,
     g_param_spec_object ("regionInfo",
                         NULL,
                         NULL,
                         TYPE_T_H_REGION_INFO,
                         G_PARAM_READWRITE));
}

GType
t_h_region_location_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THRegionLocationClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_region_location_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THRegionLocation),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_region_location_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THRegionLocationType",
                                   &type_info, 0);
  }

  return type;
}

enum _TIOErrorProperties
{
  PROP_T_I_O_ERROR_0,
  PROP_T_I_O_ERROR_MESSAGE
};

/* reads a t_i_o_error object */
static gint32
t_i_o_error_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TIOError * this_object = T_I_O_ERROR(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_i_o_error_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TIOError * this_object = T_I_O_ERROR(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TIOError", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_message == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_i_o_error_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  TIOError *self = T_I_O_ERROR (object);

  switch (property_id)
  {
    case PROP_T_I_O_ERROR_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_i_o_error_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  TIOError *self = T_I_O_ERROR (object);

  switch (property_id)
  {
    case PROP_T_I_O_ERROR_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_i_o_error_instance_init (TIOError * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->message = NULL;
  object->__isset_message = FALSE;
}

static void 
t_i_o_error_finalize (GObject *object)
{
  TIOError *tobject = T_I_O_ERROR (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
}

static void
t_i_o_error_class_init (TIOErrorClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_i_o_error_read;
  struct_class->write = t_i_o_error_write;

  gobject_class->finalize = t_i_o_error_finalize;
  gobject_class->get_property = t_i_o_error_get_property;
  gobject_class->set_property = t_i_o_error_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_I_O_ERROR_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
t_i_o_error_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TIOErrorClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_i_o_error_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TIOError),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_i_o_error_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TIOErrorType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define T_I_O_ERROR_ERROR_DOMAIN "t_i_o_error_error_quark"
GQuark
t_i_o_error_error_quark (void)
{
  return g_quark_from_static_string (T_I_O_ERROR_ERROR_DOMAIN);
}

enum _TIllegalArgumentProperties
{
  PROP_T_ILLEGAL_ARGUMENT_0,
  PROP_T_ILLEGAL_ARGUMENT_MESSAGE
};

/* reads a t_illegal_argument object */
static gint32
t_illegal_argument_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TIllegalArgument * this_object = T_ILLEGAL_ARGUMENT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_illegal_argument_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TIllegalArgument * this_object = T_ILLEGAL_ARGUMENT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TIllegalArgument", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_message == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_illegal_argument_set_property (GObject *object,
                                 guint property_id,
                                 const GValue *value,
                                 GParamSpec *pspec)
{
  TIllegalArgument *self = T_ILLEGAL_ARGUMENT (object);

  switch (property_id)
  {
    case PROP_T_ILLEGAL_ARGUMENT_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_illegal_argument_get_property (GObject *object,
                                 guint property_id,
                                 GValue *value,
                                 GParamSpec *pspec)
{
  TIllegalArgument *self = T_ILLEGAL_ARGUMENT (object);

  switch (property_id)
  {
    case PROP_T_ILLEGAL_ARGUMENT_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_illegal_argument_instance_init (TIllegalArgument * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->message = NULL;
  object->__isset_message = FALSE;
}

static void 
t_illegal_argument_finalize (GObject *object)
{
  TIllegalArgument *tobject = T_ILLEGAL_ARGUMENT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
}

static void
t_illegal_argument_class_init (TIllegalArgumentClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_illegal_argument_read;
  struct_class->write = t_illegal_argument_write;

  gobject_class->finalize = t_illegal_argument_finalize;
  gobject_class->get_property = t_illegal_argument_get_property;
  gobject_class->set_property = t_illegal_argument_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_ILLEGAL_ARGUMENT_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
t_illegal_argument_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TIllegalArgumentClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_illegal_argument_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TIllegalArgument),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_illegal_argument_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TIllegalArgumentType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define T_ILLEGAL_ARGUMENT_ERROR_DOMAIN "t_illegal_argument_error_quark"
GQuark
t_illegal_argument_error_quark (void)
{
  return g_quark_from_static_string (T_ILLEGAL_ARGUMENT_ERROR_DOMAIN);
}

/* constants */

enum _THBaseServiceExistsArgsProperties
{
  PROP_T_H_BASE_SERVICE_EXISTS_ARGS_0,
  PROP_T_H_BASE_SERVICE_EXISTS_ARGS_TABLE,
  PROP_T_H_BASE_SERVICE_EXISTS_ARGS_TGET
};

/* reads a t_h_base_service_exists_args object */
static gint32
t_h_base_service_exists_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceExistsArgs * this_object = T_H_BASE_SERVICE_EXISTS_ARGS(object);
  gboolean isset_table = FALSE;
  gboolean isset_tget = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tget), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_tget = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_table)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_tget)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_exists_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceExistsArgs * this_object = T_H_BASE_SERVICE_EXISTS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceExistsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tget", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tget), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_exists_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  THBaseServiceExistsArgs *self = T_H_BASE_SERVICE_EXISTS_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_EXISTS_ARGS_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_EXISTS_ARGS_TGET:
      if (self->tget != NULL)
        g_object_unref (self->tget);
      self->tget = g_value_dup_object (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_exists_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  THBaseServiceExistsArgs *self = T_H_BASE_SERVICE_EXISTS_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_EXISTS_ARGS_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    case PROP_T_H_BASE_SERVICE_EXISTS_ARGS_TGET:
      g_value_set_object (value, self->tget);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_exists_args_instance_init (THBaseServiceExistsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
  object->tget = g_object_new (TYPE_T_GET, NULL);
}

static void 
t_h_base_service_exists_args_finalize (GObject *object)
{
  THBaseServiceExistsArgs *tobject = T_H_BASE_SERVICE_EXISTS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->tget != NULL)
  {
    g_object_unref(tobject->tget);
    tobject->tget = NULL;
  }
}

static void
t_h_base_service_exists_args_class_init (THBaseServiceExistsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_exists_args_read;
  struct_class->write = t_h_base_service_exists_args_write;

  gobject_class->finalize = t_h_base_service_exists_args_finalize;
  gobject_class->get_property = t_h_base_service_exists_args_get_property;
  gobject_class->set_property = t_h_base_service_exists_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_EXISTS_ARGS_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_EXISTS_ARGS_TGET,
     g_param_spec_object ("tget",
                         NULL,
                         NULL,
                         TYPE_T_GET,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_exists_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceExistsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_exists_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceExistsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_exists_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceExistsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceExistsResultProperties
{
  PROP_T_H_BASE_SERVICE_EXISTS_RESULT_0,
  PROP_T_H_BASE_SERVICE_EXISTS_RESULT_SUCCESS,
  PROP_T_H_BASE_SERVICE_EXISTS_RESULT_IO
};

/* reads a t_h_base_service_exists_result object */
static gint32
t_h_base_service_exists_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceExistsResult * this_object = T_H_BASE_SERVICE_EXISTS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_exists_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceExistsResult * this_object = T_H_BASE_SERVICE_EXISTS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceExistsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_exists_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  THBaseServiceExistsResult *self = T_H_BASE_SERVICE_EXISTS_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_EXISTS_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_EXISTS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_exists_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  THBaseServiceExistsResult *self = T_H_BASE_SERVICE_EXISTS_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_EXISTS_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_T_H_BASE_SERVICE_EXISTS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_exists_result_instance_init (THBaseServiceExistsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
t_h_base_service_exists_result_finalize (GObject *object)
{
  THBaseServiceExistsResult *tobject = T_H_BASE_SERVICE_EXISTS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
t_h_base_service_exists_result_class_init (THBaseServiceExistsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_exists_result_read;
  struct_class->write = t_h_base_service_exists_result_write;

  gobject_class->finalize = t_h_base_service_exists_result_finalize;
  gobject_class->get_property = t_h_base_service_exists_result_get_property;
  gobject_class->set_property = t_h_base_service_exists_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_EXISTS_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_EXISTS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_exists_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceExistsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_exists_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceExistsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_exists_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceExistsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceExistsAllArgsProperties
{
  PROP_T_H_BASE_SERVICE_EXISTS_ALL_ARGS_0,
  PROP_T_H_BASE_SERVICE_EXISTS_ALL_ARGS_TABLE,
  PROP_T_H_BASE_SERVICE_EXISTS_ALL_ARGS_TGETS
};

/* reads a t_h_base_service_exists_all_args object */
static gint32
t_h_base_service_exists_all_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceExistsAllArgs * this_object = T_H_BASE_SERVICE_EXISTS_ALL_ARGS(object);
  gboolean isset_table = FALSE;
  gboolean isset_tgets = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TGet * _elem51 = NULL;
              if ( _elem51 != NULL)
              {
                g_object_unref (_elem51);
              }
              _elem51 = g_object_new (TYPE_T_GET, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem51), protocol, error)) < 0)
              {
                g_object_unref (_elem51);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->tgets, _elem51);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_tgets = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_table)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_tgets)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_exists_all_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceExistsAllArgs * this_object = T_H_BASE_SERVICE_EXISTS_ALL_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceExistsAllArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tgets", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i52;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->tgets ? this_object->tgets->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i52 = 0; i52 < (this_object->tgets ? this_object->tgets->len : 0); i52++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->tgets, i52))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_exists_all_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  THBaseServiceExistsAllArgs *self = T_H_BASE_SERVICE_EXISTS_ALL_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_EXISTS_ALL_ARGS_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_EXISTS_ALL_ARGS_TGETS:
      if (self->tgets != NULL)
        g_ptr_array_unref (self->tgets);
      self->tgets = g_value_dup_boxed (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_exists_all_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  THBaseServiceExistsAllArgs *self = T_H_BASE_SERVICE_EXISTS_ALL_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_EXISTS_ALL_ARGS_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    case PROP_T_H_BASE_SERVICE_EXISTS_ALL_ARGS_TGETS:
      g_value_set_boxed (value, self->tgets);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_exists_all_args_instance_init (THBaseServiceExistsAllArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
  object->tgets = g_ptr_array_new_with_free_func (g_object_unref);
}

static void 
t_h_base_service_exists_all_args_finalize (GObject *object)
{
  THBaseServiceExistsAllArgs *tobject = T_H_BASE_SERVICE_EXISTS_ALL_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->tgets != NULL)
  {
    g_ptr_array_unref (tobject->tgets);
    tobject->tgets = NULL;
  }
}

static void
t_h_base_service_exists_all_args_class_init (THBaseServiceExistsAllArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_exists_all_args_read;
  struct_class->write = t_h_base_service_exists_all_args_write;

  gobject_class->finalize = t_h_base_service_exists_all_args_finalize;
  gobject_class->get_property = t_h_base_service_exists_all_args_get_property;
  gobject_class->set_property = t_h_base_service_exists_all_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_EXISTS_ALL_ARGS_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_EXISTS_ALL_ARGS_TGETS,
     g_param_spec_boxed ("tgets",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_exists_all_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceExistsAllArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_exists_all_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceExistsAllArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_exists_all_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceExistsAllArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceExistsAllResultProperties
{
  PROP_T_H_BASE_SERVICE_EXISTS_ALL_RESULT_0,
  PROP_T_H_BASE_SERVICE_EXISTS_ALL_RESULT_SUCCESS,
  PROP_T_H_BASE_SERVICE_EXISTS_ALL_RESULT_IO
};

/* reads a t_h_base_service_exists_all_result object */
static gint32
t_h_base_service_exists_all_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceExistsAllResult * this_object = T_H_BASE_SERVICE_EXISTS_ALL_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gboolean* _elem53 = g_new (gboolean, 1);
              if ((ret = thrift_protocol_read_bool (protocol, &*_elem53, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem53, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_exists_all_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceExistsAllResult * this_object = T_H_BASE_SERVICE_EXISTS_ALL_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceExistsAllResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i54;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_BOOL, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i54 = 0; i54 < (this_object->success ? this_object->success->len : 0); i54++)
      {
        if ((ret = thrift_protocol_write_bool (protocol, (g_array_index (this_object->success, gboolean, i54)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_exists_all_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  THBaseServiceExistsAllResult *self = T_H_BASE_SERVICE_EXISTS_ALL_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_EXISTS_ALL_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_EXISTS_ALL_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_exists_all_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  THBaseServiceExistsAllResult *self = T_H_BASE_SERVICE_EXISTS_ALL_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_EXISTS_ALL_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_T_H_BASE_SERVICE_EXISTS_ALL_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_exists_all_result_instance_init (THBaseServiceExistsAllResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gboolean));
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
t_h_base_service_exists_all_result_finalize (GObject *object)
{
  THBaseServiceExistsAllResult *tobject = T_H_BASE_SERVICE_EXISTS_ALL_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
t_h_base_service_exists_all_result_class_init (THBaseServiceExistsAllResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_exists_all_result_read;
  struct_class->write = t_h_base_service_exists_all_result_write;

  gobject_class->finalize = t_h_base_service_exists_all_result_finalize;
  gobject_class->get_property = t_h_base_service_exists_all_result_get_property;
  gobject_class->set_property = t_h_base_service_exists_all_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_EXISTS_ALL_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_EXISTS_ALL_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_exists_all_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceExistsAllResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_exists_all_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceExistsAllResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_exists_all_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceExistsAllResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceGetArgsProperties
{
  PROP_T_H_BASE_SERVICE_GET_ARGS_0,
  PROP_T_H_BASE_SERVICE_GET_ARGS_TABLE,
  PROP_T_H_BASE_SERVICE_GET_ARGS_TGET
};

/* reads a t_h_base_service_get_args object */
static gint32
t_h_base_service_get_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceGetArgs * this_object = T_H_BASE_SERVICE_GET_ARGS(object);
  gboolean isset_table = FALSE;
  gboolean isset_tget = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tget), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_tget = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_table)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_tget)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_get_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceGetArgs * this_object = T_H_BASE_SERVICE_GET_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceGetArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tget", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tget), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_get_args_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  THBaseServiceGetArgs *self = T_H_BASE_SERVICE_GET_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_ARGS_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_GET_ARGS_TGET:
      if (self->tget != NULL)
        g_object_unref (self->tget);
      self->tget = g_value_dup_object (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_get_args_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  THBaseServiceGetArgs *self = T_H_BASE_SERVICE_GET_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_ARGS_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    case PROP_T_H_BASE_SERVICE_GET_ARGS_TGET:
      g_value_set_object (value, self->tget);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_get_args_instance_init (THBaseServiceGetArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
  object->tget = g_object_new (TYPE_T_GET, NULL);
}

static void 
t_h_base_service_get_args_finalize (GObject *object)
{
  THBaseServiceGetArgs *tobject = T_H_BASE_SERVICE_GET_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->tget != NULL)
  {
    g_object_unref(tobject->tget);
    tobject->tget = NULL;
  }
}

static void
t_h_base_service_get_args_class_init (THBaseServiceGetArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_get_args_read;
  struct_class->write = t_h_base_service_get_args_write;

  gobject_class->finalize = t_h_base_service_get_args_finalize;
  gobject_class->get_property = t_h_base_service_get_args_get_property;
  gobject_class->set_property = t_h_base_service_get_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_ARGS_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_ARGS_TGET,
     g_param_spec_object ("tget",
                         NULL,
                         NULL,
                         TYPE_T_GET,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_get_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceGetArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_get_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceGetArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_get_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceGetArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceGetResultProperties
{
  PROP_T_H_BASE_SERVICE_GET_RESULT_0,
  PROP_T_H_BASE_SERVICE_GET_RESULT_SUCCESS,
  PROP_T_H_BASE_SERVICE_GET_RESULT_IO
};

/* reads a t_h_base_service_get_result object */
static gint32
t_h_base_service_get_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceGetResult * this_object = T_H_BASE_SERVICE_GET_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_get_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceGetResult * this_object = T_H_BASE_SERVICE_GET_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceGetResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_get_result_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  THBaseServiceGetResult *self = T_H_BASE_SERVICE_GET_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_GET_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_get_result_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  THBaseServiceGetResult *self = T_H_BASE_SERVICE_GET_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_T_H_BASE_SERVICE_GET_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_get_result_instance_init (THBaseServiceGetResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_T_RESULT, NULL);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
t_h_base_service_get_result_finalize (GObject *object)
{
  THBaseServiceGetResult *tobject = T_H_BASE_SERVICE_GET_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
t_h_base_service_get_result_class_init (THBaseServiceGetResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_get_result_read;
  struct_class->write = t_h_base_service_get_result_write;

  gobject_class->finalize = t_h_base_service_get_result_finalize;
  gobject_class->get_property = t_h_base_service_get_result_get_property;
  gobject_class->set_property = t_h_base_service_get_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_T_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_get_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceGetResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_get_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceGetResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_get_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceGetResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceGetMultipleArgsProperties
{
  PROP_T_H_BASE_SERVICE_GET_MULTIPLE_ARGS_0,
  PROP_T_H_BASE_SERVICE_GET_MULTIPLE_ARGS_TABLE,
  PROP_T_H_BASE_SERVICE_GET_MULTIPLE_ARGS_TGETS
};

/* reads a t_h_base_service_get_multiple_args object */
static gint32
t_h_base_service_get_multiple_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceGetMultipleArgs * this_object = T_H_BASE_SERVICE_GET_MULTIPLE_ARGS(object);
  gboolean isset_table = FALSE;
  gboolean isset_tgets = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TGet * _elem55 = NULL;
              if ( _elem55 != NULL)
              {
                g_object_unref (_elem55);
              }
              _elem55 = g_object_new (TYPE_T_GET, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem55), protocol, error)) < 0)
              {
                g_object_unref (_elem55);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->tgets, _elem55);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_tgets = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_table)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_tgets)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_get_multiple_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceGetMultipleArgs * this_object = T_H_BASE_SERVICE_GET_MULTIPLE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceGetMultipleArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tgets", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i56;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->tgets ? this_object->tgets->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i56 = 0; i56 < (this_object->tgets ? this_object->tgets->len : 0); i56++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->tgets, i56))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_get_multiple_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  THBaseServiceGetMultipleArgs *self = T_H_BASE_SERVICE_GET_MULTIPLE_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_MULTIPLE_ARGS_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_GET_MULTIPLE_ARGS_TGETS:
      if (self->tgets != NULL)
        g_ptr_array_unref (self->tgets);
      self->tgets = g_value_dup_boxed (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_get_multiple_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  THBaseServiceGetMultipleArgs *self = T_H_BASE_SERVICE_GET_MULTIPLE_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_MULTIPLE_ARGS_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    case PROP_T_H_BASE_SERVICE_GET_MULTIPLE_ARGS_TGETS:
      g_value_set_boxed (value, self->tgets);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_get_multiple_args_instance_init (THBaseServiceGetMultipleArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
  object->tgets = g_ptr_array_new_with_free_func (g_object_unref);
}

static void 
t_h_base_service_get_multiple_args_finalize (GObject *object)
{
  THBaseServiceGetMultipleArgs *tobject = T_H_BASE_SERVICE_GET_MULTIPLE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->tgets != NULL)
  {
    g_ptr_array_unref (tobject->tgets);
    tobject->tgets = NULL;
  }
}

static void
t_h_base_service_get_multiple_args_class_init (THBaseServiceGetMultipleArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_get_multiple_args_read;
  struct_class->write = t_h_base_service_get_multiple_args_write;

  gobject_class->finalize = t_h_base_service_get_multiple_args_finalize;
  gobject_class->get_property = t_h_base_service_get_multiple_args_get_property;
  gobject_class->set_property = t_h_base_service_get_multiple_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_MULTIPLE_ARGS_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_MULTIPLE_ARGS_TGETS,
     g_param_spec_boxed ("tgets",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_get_multiple_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceGetMultipleArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_get_multiple_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceGetMultipleArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_get_multiple_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceGetMultipleArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceGetMultipleResultProperties
{
  PROP_T_H_BASE_SERVICE_GET_MULTIPLE_RESULT_0,
  PROP_T_H_BASE_SERVICE_GET_MULTIPLE_RESULT_SUCCESS,
  PROP_T_H_BASE_SERVICE_GET_MULTIPLE_RESULT_IO
};

/* reads a t_h_base_service_get_multiple_result object */
static gint32
t_h_base_service_get_multiple_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceGetMultipleResult * this_object = T_H_BASE_SERVICE_GET_MULTIPLE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TResult * _elem57 = NULL;
              if ( _elem57 != NULL)
              {
                g_object_unref (_elem57);
              }
              _elem57 = g_object_new (TYPE_T_RESULT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem57), protocol, error)) < 0)
              {
                g_object_unref (_elem57);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem57);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_get_multiple_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceGetMultipleResult * this_object = T_H_BASE_SERVICE_GET_MULTIPLE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceGetMultipleResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i58;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i58 = 0; i58 < (this_object->success ? this_object->success->len : 0); i58++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i58))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_get_multiple_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  THBaseServiceGetMultipleResult *self = T_H_BASE_SERVICE_GET_MULTIPLE_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_MULTIPLE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_GET_MULTIPLE_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_get_multiple_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  THBaseServiceGetMultipleResult *self = T_H_BASE_SERVICE_GET_MULTIPLE_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_MULTIPLE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_T_H_BASE_SERVICE_GET_MULTIPLE_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_get_multiple_result_instance_init (THBaseServiceGetMultipleResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
t_h_base_service_get_multiple_result_finalize (GObject *object)
{
  THBaseServiceGetMultipleResult *tobject = T_H_BASE_SERVICE_GET_MULTIPLE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
t_h_base_service_get_multiple_result_class_init (THBaseServiceGetMultipleResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_get_multiple_result_read;
  struct_class->write = t_h_base_service_get_multiple_result_write;

  gobject_class->finalize = t_h_base_service_get_multiple_result_finalize;
  gobject_class->get_property = t_h_base_service_get_multiple_result_get_property;
  gobject_class->set_property = t_h_base_service_get_multiple_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_MULTIPLE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_MULTIPLE_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_get_multiple_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceGetMultipleResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_get_multiple_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceGetMultipleResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_get_multiple_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceGetMultipleResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServicePutArgsProperties
{
  PROP_T_H_BASE_SERVICE_PUT_ARGS_0,
  PROP_T_H_BASE_SERVICE_PUT_ARGS_TABLE,
  PROP_T_H_BASE_SERVICE_PUT_ARGS_TPUT
};

/* reads a t_h_base_service_put_args object */
static gint32
t_h_base_service_put_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServicePutArgs * this_object = T_H_BASE_SERVICE_PUT_ARGS(object);
  gboolean isset_table = FALSE;
  gboolean isset_tput = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tput), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_tput = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_table)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_tput)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_put_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServicePutArgs * this_object = T_H_BASE_SERVICE_PUT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServicePutArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tput", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tput), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_put_args_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  THBaseServicePutArgs *self = T_H_BASE_SERVICE_PUT_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_PUT_ARGS_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_PUT_ARGS_TPUT:
      if (self->tput != NULL)
        g_object_unref (self->tput);
      self->tput = g_value_dup_object (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_put_args_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  THBaseServicePutArgs *self = T_H_BASE_SERVICE_PUT_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_PUT_ARGS_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    case PROP_T_H_BASE_SERVICE_PUT_ARGS_TPUT:
      g_value_set_object (value, self->tput);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_put_args_instance_init (THBaseServicePutArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
  object->tput = g_object_new (TYPE_T_PUT, NULL);
}

static void 
t_h_base_service_put_args_finalize (GObject *object)
{
  THBaseServicePutArgs *tobject = T_H_BASE_SERVICE_PUT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->tput != NULL)
  {
    g_object_unref(tobject->tput);
    tobject->tput = NULL;
  }
}

static void
t_h_base_service_put_args_class_init (THBaseServicePutArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_put_args_read;
  struct_class->write = t_h_base_service_put_args_write;

  gobject_class->finalize = t_h_base_service_put_args_finalize;
  gobject_class->get_property = t_h_base_service_put_args_get_property;
  gobject_class->set_property = t_h_base_service_put_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_PUT_ARGS_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_PUT_ARGS_TPUT,
     g_param_spec_object ("tput",
                         NULL,
                         NULL,
                         TYPE_T_PUT,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_put_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServicePutArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_put_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServicePutArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_put_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServicePutArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServicePutResultProperties
{
  PROP_T_H_BASE_SERVICE_PUT_RESULT_0,
  PROP_T_H_BASE_SERVICE_PUT_RESULT_IO
};

/* reads a t_h_base_service_put_result object */
static gint32
t_h_base_service_put_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServicePutResult * this_object = T_H_BASE_SERVICE_PUT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_put_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServicePutResult * this_object = T_H_BASE_SERVICE_PUT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServicePutResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_put_result_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  THBaseServicePutResult *self = T_H_BASE_SERVICE_PUT_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_PUT_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_put_result_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  THBaseServicePutResult *self = T_H_BASE_SERVICE_PUT_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_PUT_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_put_result_instance_init (THBaseServicePutResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
t_h_base_service_put_result_finalize (GObject *object)
{
  THBaseServicePutResult *tobject = T_H_BASE_SERVICE_PUT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
t_h_base_service_put_result_class_init (THBaseServicePutResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_put_result_read;
  struct_class->write = t_h_base_service_put_result_write;

  gobject_class->finalize = t_h_base_service_put_result_finalize;
  gobject_class->get_property = t_h_base_service_put_result_get_property;
  gobject_class->set_property = t_h_base_service_put_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_PUT_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_put_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServicePutResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_put_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServicePutResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_put_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServicePutResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceCheckAndPutArgsProperties
{
  PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_0,
  PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_TABLE,
  PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_ROW,
  PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_FAMILY,
  PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_QUALIFIER,
  PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_VALUE,
  PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_TPUT
};

/* reads a t_h_base_service_check_and_put_args object */
static gint32
t_h_base_service_check_and_put_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceCheckAndPutArgs * this_object = T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS(object);
  gboolean isset_table = FALSE;
  gboolean isset_row = FALSE;
  gboolean isset_family = FALSE;
  gboolean isset_qualifier = FALSE;
  gboolean isset_tput = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->family != NULL)
          {
            g_free(this_object->family);
            this_object->family = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->family = g_byte_array_new();
          g_byte_array_append (this_object->family, (guint8 *) data, (guint) len);
          g_free (data);
          isset_family = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->qualifier != NULL)
          {
            g_free(this_object->qualifier);
            this_object->qualifier = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->qualifier = g_byte_array_new();
          g_byte_array_append (this_object->qualifier, (guint8 *) data, (guint) len);
          g_free (data);
          isset_qualifier = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->value = g_byte_array_new();
          g_byte_array_append (this_object->value, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tput), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_tput = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_table)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_row)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_family)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_qualifier)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_tput)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_check_and_put_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceCheckAndPutArgs * this_object = T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceCheckAndPutArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "family", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->family ? ((GByteArray *) this_object->family)->data : NULL, this_object->family ? ((GByteArray *) this_object->family)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "qualifier", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->qualifier ? ((GByteArray *) this_object->qualifier)->data : NULL, this_object->qualifier ? ((GByteArray *) this_object->qualifier)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->value ? ((GByteArray *) this_object->value)->data : NULL, this_object->value ? ((GByteArray *) this_object->value)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tput", T_STRUCT, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tput), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_check_and_put_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  THBaseServiceCheckAndPutArgs *self = T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_FAMILY:
      if (self->family != NULL)
        g_byte_array_unref (self->family);
      self->family = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_QUALIFIER:
      if (self->qualifier != NULL)
        g_byte_array_unref (self->qualifier);
      self->qualifier = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_VALUE:
      if (self->value != NULL)
        g_byte_array_unref (self->value);
      self->value = g_value_dup_boxed (value);
      self->__isset_value = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_TPUT:
      if (self->tput != NULL)
        g_object_unref (self->tput);
      self->tput = g_value_dup_object (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_check_and_put_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  THBaseServiceCheckAndPutArgs *self = T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_FAMILY:
      g_value_set_boxed (value, self->family);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_QUALIFIER:
      g_value_set_boxed (value, self->qualifier);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_VALUE:
      g_value_set_boxed (value, self->value);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_TPUT:
      g_value_set_object (value, self->tput);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_check_and_put_args_instance_init (THBaseServiceCheckAndPutArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
  object->row = NULL;
  object->family = NULL;
  object->qualifier = NULL;
  object->value = NULL;
  object->__isset_value = FALSE;
  object->tput = g_object_new (TYPE_T_PUT, NULL);
}

static void 
t_h_base_service_check_and_put_args_finalize (GObject *object)
{
  THBaseServiceCheckAndPutArgs *tobject = T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->family != NULL)
  {
    thrift_string_free(tobject->family);
    tobject->family = NULL;
  }
  if (tobject->qualifier != NULL)
  {
    thrift_string_free(tobject->qualifier);
    tobject->qualifier = NULL;
  }
  if (tobject->value != NULL)
  {
    thrift_string_free(tobject->value);
    tobject->value = NULL;
  }
  if (tobject->tput != NULL)
  {
    g_object_unref(tobject->tput);
    tobject->tput = NULL;
  }
}

static void
t_h_base_service_check_and_put_args_class_init (THBaseServiceCheckAndPutArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_check_and_put_args_read;
  struct_class->write = t_h_base_service_check_and_put_args_write;

  gobject_class->finalize = t_h_base_service_check_and_put_args_finalize;
  gobject_class->get_property = t_h_base_service_check_and_put_args_get_property;
  gobject_class->set_property = t_h_base_service_check_and_put_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_FAMILY,
     g_param_spec_boxed ("family",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_QUALIFIER,
     g_param_spec_boxed ("qualifier",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_VALUE,
     g_param_spec_boxed ("value",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_ARGS_TPUT,
     g_param_spec_object ("tput",
                         NULL,
                         NULL,
                         TYPE_T_PUT,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_check_and_put_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceCheckAndPutArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_check_and_put_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceCheckAndPutArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_check_and_put_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceCheckAndPutArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceCheckAndPutResultProperties
{
  PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_RESULT_0,
  PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_RESULT_SUCCESS,
  PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_RESULT_IO
};

/* reads a t_h_base_service_check_and_put_result object */
static gint32
t_h_base_service_check_and_put_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceCheckAndPutResult * this_object = T_H_BASE_SERVICE_CHECK_AND_PUT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_check_and_put_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceCheckAndPutResult * this_object = T_H_BASE_SERVICE_CHECK_AND_PUT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceCheckAndPutResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_check_and_put_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  THBaseServiceCheckAndPutResult *self = T_H_BASE_SERVICE_CHECK_AND_PUT_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_check_and_put_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  THBaseServiceCheckAndPutResult *self = T_H_BASE_SERVICE_CHECK_AND_PUT_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_check_and_put_result_instance_init (THBaseServiceCheckAndPutResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
t_h_base_service_check_and_put_result_finalize (GObject *object)
{
  THBaseServiceCheckAndPutResult *tobject = T_H_BASE_SERVICE_CHECK_AND_PUT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
t_h_base_service_check_and_put_result_class_init (THBaseServiceCheckAndPutResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_check_and_put_result_read;
  struct_class->write = t_h_base_service_check_and_put_result_write;

  gobject_class->finalize = t_h_base_service_check_and_put_result_finalize;
  gobject_class->get_property = t_h_base_service_check_and_put_result_get_property;
  gobject_class->set_property = t_h_base_service_check_and_put_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_PUT_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_check_and_put_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceCheckAndPutResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_check_and_put_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceCheckAndPutResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_check_and_put_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceCheckAndPutResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServicePutMultipleArgsProperties
{
  PROP_T_H_BASE_SERVICE_PUT_MULTIPLE_ARGS_0,
  PROP_T_H_BASE_SERVICE_PUT_MULTIPLE_ARGS_TABLE,
  PROP_T_H_BASE_SERVICE_PUT_MULTIPLE_ARGS_TPUTS
};

/* reads a t_h_base_service_put_multiple_args object */
static gint32
t_h_base_service_put_multiple_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServicePutMultipleArgs * this_object = T_H_BASE_SERVICE_PUT_MULTIPLE_ARGS(object);
  gboolean isset_table = FALSE;
  gboolean isset_tputs = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TPut * _elem59 = NULL;
              if ( _elem59 != NULL)
              {
                g_object_unref (_elem59);
              }
              _elem59 = g_object_new (TYPE_T_PUT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem59), protocol, error)) < 0)
              {
                g_object_unref (_elem59);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->tputs, _elem59);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_tputs = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_table)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_tputs)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_put_multiple_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServicePutMultipleArgs * this_object = T_H_BASE_SERVICE_PUT_MULTIPLE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServicePutMultipleArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tputs", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i60;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->tputs ? this_object->tputs->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i60 = 0; i60 < (this_object->tputs ? this_object->tputs->len : 0); i60++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->tputs, i60))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_put_multiple_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  THBaseServicePutMultipleArgs *self = T_H_BASE_SERVICE_PUT_MULTIPLE_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_PUT_MULTIPLE_ARGS_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_PUT_MULTIPLE_ARGS_TPUTS:
      if (self->tputs != NULL)
        g_ptr_array_unref (self->tputs);
      self->tputs = g_value_dup_boxed (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_put_multiple_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  THBaseServicePutMultipleArgs *self = T_H_BASE_SERVICE_PUT_MULTIPLE_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_PUT_MULTIPLE_ARGS_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    case PROP_T_H_BASE_SERVICE_PUT_MULTIPLE_ARGS_TPUTS:
      g_value_set_boxed (value, self->tputs);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_put_multiple_args_instance_init (THBaseServicePutMultipleArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
  object->tputs = g_ptr_array_new_with_free_func (g_object_unref);
}

static void 
t_h_base_service_put_multiple_args_finalize (GObject *object)
{
  THBaseServicePutMultipleArgs *tobject = T_H_BASE_SERVICE_PUT_MULTIPLE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->tputs != NULL)
  {
    g_ptr_array_unref (tobject->tputs);
    tobject->tputs = NULL;
  }
}

static void
t_h_base_service_put_multiple_args_class_init (THBaseServicePutMultipleArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_put_multiple_args_read;
  struct_class->write = t_h_base_service_put_multiple_args_write;

  gobject_class->finalize = t_h_base_service_put_multiple_args_finalize;
  gobject_class->get_property = t_h_base_service_put_multiple_args_get_property;
  gobject_class->set_property = t_h_base_service_put_multiple_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_PUT_MULTIPLE_ARGS_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_PUT_MULTIPLE_ARGS_TPUTS,
     g_param_spec_boxed ("tputs",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_put_multiple_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServicePutMultipleArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_put_multiple_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServicePutMultipleArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_put_multiple_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServicePutMultipleArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServicePutMultipleResultProperties
{
  PROP_T_H_BASE_SERVICE_PUT_MULTIPLE_RESULT_0,
  PROP_T_H_BASE_SERVICE_PUT_MULTIPLE_RESULT_IO
};

/* reads a t_h_base_service_put_multiple_result object */
static gint32
t_h_base_service_put_multiple_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServicePutMultipleResult * this_object = T_H_BASE_SERVICE_PUT_MULTIPLE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_put_multiple_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServicePutMultipleResult * this_object = T_H_BASE_SERVICE_PUT_MULTIPLE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServicePutMultipleResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_put_multiple_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  THBaseServicePutMultipleResult *self = T_H_BASE_SERVICE_PUT_MULTIPLE_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_PUT_MULTIPLE_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_put_multiple_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  THBaseServicePutMultipleResult *self = T_H_BASE_SERVICE_PUT_MULTIPLE_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_PUT_MULTIPLE_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_put_multiple_result_instance_init (THBaseServicePutMultipleResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
t_h_base_service_put_multiple_result_finalize (GObject *object)
{
  THBaseServicePutMultipleResult *tobject = T_H_BASE_SERVICE_PUT_MULTIPLE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
t_h_base_service_put_multiple_result_class_init (THBaseServicePutMultipleResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_put_multiple_result_read;
  struct_class->write = t_h_base_service_put_multiple_result_write;

  gobject_class->finalize = t_h_base_service_put_multiple_result_finalize;
  gobject_class->get_property = t_h_base_service_put_multiple_result_get_property;
  gobject_class->set_property = t_h_base_service_put_multiple_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_PUT_MULTIPLE_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_put_multiple_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServicePutMultipleResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_put_multiple_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServicePutMultipleResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_put_multiple_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServicePutMultipleResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceDeleteSingleArgsProperties
{
  PROP_T_H_BASE_SERVICE_DELETE_SINGLE_ARGS_0,
  PROP_T_H_BASE_SERVICE_DELETE_SINGLE_ARGS_TABLE,
  PROP_T_H_BASE_SERVICE_DELETE_SINGLE_ARGS_TDELETE
};

/* reads a t_h_base_service_delete_single_args object */
static gint32
t_h_base_service_delete_single_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceDeleteSingleArgs * this_object = T_H_BASE_SERVICE_DELETE_SINGLE_ARGS(object);
  gboolean isset_table = FALSE;
  gboolean isset_tdelete = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tdelete), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_tdelete = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_table)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_tdelete)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_delete_single_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceDeleteSingleArgs * this_object = T_H_BASE_SERVICE_DELETE_SINGLE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceDeleteSingleArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tdelete", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tdelete), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_delete_single_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  THBaseServiceDeleteSingleArgs *self = T_H_BASE_SERVICE_DELETE_SINGLE_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_DELETE_SINGLE_ARGS_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_DELETE_SINGLE_ARGS_TDELETE:
      if (self->tdelete != NULL)
        g_object_unref (self->tdelete);
      self->tdelete = g_value_dup_object (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_delete_single_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  THBaseServiceDeleteSingleArgs *self = T_H_BASE_SERVICE_DELETE_SINGLE_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_DELETE_SINGLE_ARGS_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    case PROP_T_H_BASE_SERVICE_DELETE_SINGLE_ARGS_TDELETE:
      g_value_set_object (value, self->tdelete);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_delete_single_args_instance_init (THBaseServiceDeleteSingleArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
  object->tdelete = g_object_new (TYPE_T_DELETE, NULL);
}

static void 
t_h_base_service_delete_single_args_finalize (GObject *object)
{
  THBaseServiceDeleteSingleArgs *tobject = T_H_BASE_SERVICE_DELETE_SINGLE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->tdelete != NULL)
  {
    g_object_unref(tobject->tdelete);
    tobject->tdelete = NULL;
  }
}

static void
t_h_base_service_delete_single_args_class_init (THBaseServiceDeleteSingleArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_delete_single_args_read;
  struct_class->write = t_h_base_service_delete_single_args_write;

  gobject_class->finalize = t_h_base_service_delete_single_args_finalize;
  gobject_class->get_property = t_h_base_service_delete_single_args_get_property;
  gobject_class->set_property = t_h_base_service_delete_single_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_DELETE_SINGLE_ARGS_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_DELETE_SINGLE_ARGS_TDELETE,
     g_param_spec_object ("tdelete",
                         NULL,
                         NULL,
                         TYPE_T_DELETE,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_delete_single_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceDeleteSingleArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_delete_single_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceDeleteSingleArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_delete_single_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceDeleteSingleArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceDeleteSingleResultProperties
{
  PROP_T_H_BASE_SERVICE_DELETE_SINGLE_RESULT_0,
  PROP_T_H_BASE_SERVICE_DELETE_SINGLE_RESULT_IO
};

/* reads a t_h_base_service_delete_single_result object */
static gint32
t_h_base_service_delete_single_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceDeleteSingleResult * this_object = T_H_BASE_SERVICE_DELETE_SINGLE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_delete_single_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceDeleteSingleResult * this_object = T_H_BASE_SERVICE_DELETE_SINGLE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceDeleteSingleResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_delete_single_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  THBaseServiceDeleteSingleResult *self = T_H_BASE_SERVICE_DELETE_SINGLE_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_DELETE_SINGLE_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_delete_single_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  THBaseServiceDeleteSingleResult *self = T_H_BASE_SERVICE_DELETE_SINGLE_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_DELETE_SINGLE_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_delete_single_result_instance_init (THBaseServiceDeleteSingleResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
t_h_base_service_delete_single_result_finalize (GObject *object)
{
  THBaseServiceDeleteSingleResult *tobject = T_H_BASE_SERVICE_DELETE_SINGLE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
t_h_base_service_delete_single_result_class_init (THBaseServiceDeleteSingleResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_delete_single_result_read;
  struct_class->write = t_h_base_service_delete_single_result_write;

  gobject_class->finalize = t_h_base_service_delete_single_result_finalize;
  gobject_class->get_property = t_h_base_service_delete_single_result_get_property;
  gobject_class->set_property = t_h_base_service_delete_single_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_DELETE_SINGLE_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_delete_single_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceDeleteSingleResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_delete_single_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceDeleteSingleResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_delete_single_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceDeleteSingleResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceDeleteMultipleArgsProperties
{
  PROP_T_H_BASE_SERVICE_DELETE_MULTIPLE_ARGS_0,
  PROP_T_H_BASE_SERVICE_DELETE_MULTIPLE_ARGS_TABLE,
  PROP_T_H_BASE_SERVICE_DELETE_MULTIPLE_ARGS_TDELETES
};

/* reads a t_h_base_service_delete_multiple_args object */
static gint32
t_h_base_service_delete_multiple_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceDeleteMultipleArgs * this_object = T_H_BASE_SERVICE_DELETE_MULTIPLE_ARGS(object);
  gboolean isset_table = FALSE;
  gboolean isset_tdeletes = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TDelete * _elem61 = NULL;
              if ( _elem61 != NULL)
              {
                g_object_unref (_elem61);
              }
              _elem61 = g_object_new (TYPE_T_DELETE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem61), protocol, error)) < 0)
              {
                g_object_unref (_elem61);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->tdeletes, _elem61);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_tdeletes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_table)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_tdeletes)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_delete_multiple_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceDeleteMultipleArgs * this_object = T_H_BASE_SERVICE_DELETE_MULTIPLE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceDeleteMultipleArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tdeletes", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i62;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->tdeletes ? this_object->tdeletes->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i62 = 0; i62 < (this_object->tdeletes ? this_object->tdeletes->len : 0); i62++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->tdeletes, i62))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_delete_multiple_args_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  THBaseServiceDeleteMultipleArgs *self = T_H_BASE_SERVICE_DELETE_MULTIPLE_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_DELETE_MULTIPLE_ARGS_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_DELETE_MULTIPLE_ARGS_TDELETES:
      if (self->tdeletes != NULL)
        g_ptr_array_unref (self->tdeletes);
      self->tdeletes = g_value_dup_boxed (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_delete_multiple_args_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  THBaseServiceDeleteMultipleArgs *self = T_H_BASE_SERVICE_DELETE_MULTIPLE_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_DELETE_MULTIPLE_ARGS_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    case PROP_T_H_BASE_SERVICE_DELETE_MULTIPLE_ARGS_TDELETES:
      g_value_set_boxed (value, self->tdeletes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_delete_multiple_args_instance_init (THBaseServiceDeleteMultipleArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
  object->tdeletes = g_ptr_array_new_with_free_func (g_object_unref);
}

static void 
t_h_base_service_delete_multiple_args_finalize (GObject *object)
{
  THBaseServiceDeleteMultipleArgs *tobject = T_H_BASE_SERVICE_DELETE_MULTIPLE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->tdeletes != NULL)
  {
    g_ptr_array_unref (tobject->tdeletes);
    tobject->tdeletes = NULL;
  }
}

static void
t_h_base_service_delete_multiple_args_class_init (THBaseServiceDeleteMultipleArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_delete_multiple_args_read;
  struct_class->write = t_h_base_service_delete_multiple_args_write;

  gobject_class->finalize = t_h_base_service_delete_multiple_args_finalize;
  gobject_class->get_property = t_h_base_service_delete_multiple_args_get_property;
  gobject_class->set_property = t_h_base_service_delete_multiple_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_DELETE_MULTIPLE_ARGS_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_DELETE_MULTIPLE_ARGS_TDELETES,
     g_param_spec_boxed ("tdeletes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_delete_multiple_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceDeleteMultipleArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_delete_multiple_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceDeleteMultipleArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_delete_multiple_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceDeleteMultipleArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceDeleteMultipleResultProperties
{
  PROP_T_H_BASE_SERVICE_DELETE_MULTIPLE_RESULT_0,
  PROP_T_H_BASE_SERVICE_DELETE_MULTIPLE_RESULT_SUCCESS,
  PROP_T_H_BASE_SERVICE_DELETE_MULTIPLE_RESULT_IO
};

/* reads a t_h_base_service_delete_multiple_result object */
static gint32
t_h_base_service_delete_multiple_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceDeleteMultipleResult * this_object = T_H_BASE_SERVICE_DELETE_MULTIPLE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TDelete * _elem63 = NULL;
              if ( _elem63 != NULL)
              {
                g_object_unref (_elem63);
              }
              _elem63 = g_object_new (TYPE_T_DELETE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem63), protocol, error)) < 0)
              {
                g_object_unref (_elem63);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem63);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_delete_multiple_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceDeleteMultipleResult * this_object = T_H_BASE_SERVICE_DELETE_MULTIPLE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceDeleteMultipleResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i64;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i64 = 0; i64 < (this_object->success ? this_object->success->len : 0); i64++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i64))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_delete_multiple_result_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  THBaseServiceDeleteMultipleResult *self = T_H_BASE_SERVICE_DELETE_MULTIPLE_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_DELETE_MULTIPLE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_DELETE_MULTIPLE_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_delete_multiple_result_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  THBaseServiceDeleteMultipleResult *self = T_H_BASE_SERVICE_DELETE_MULTIPLE_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_DELETE_MULTIPLE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_T_H_BASE_SERVICE_DELETE_MULTIPLE_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_delete_multiple_result_instance_init (THBaseServiceDeleteMultipleResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
t_h_base_service_delete_multiple_result_finalize (GObject *object)
{
  THBaseServiceDeleteMultipleResult *tobject = T_H_BASE_SERVICE_DELETE_MULTIPLE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
t_h_base_service_delete_multiple_result_class_init (THBaseServiceDeleteMultipleResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_delete_multiple_result_read;
  struct_class->write = t_h_base_service_delete_multiple_result_write;

  gobject_class->finalize = t_h_base_service_delete_multiple_result_finalize;
  gobject_class->get_property = t_h_base_service_delete_multiple_result_get_property;
  gobject_class->set_property = t_h_base_service_delete_multiple_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_DELETE_MULTIPLE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_DELETE_MULTIPLE_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_delete_multiple_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceDeleteMultipleResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_delete_multiple_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceDeleteMultipleResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_delete_multiple_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceDeleteMultipleResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceCheckAndDeleteArgsProperties
{
  PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_0,
  PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_TABLE,
  PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_ROW,
  PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_FAMILY,
  PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_QUALIFIER,
  PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_VALUE,
  PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_TDELETE
};

/* reads a t_h_base_service_check_and_delete_args object */
static gint32
t_h_base_service_check_and_delete_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceCheckAndDeleteArgs * this_object = T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS(object);
  gboolean isset_table = FALSE;
  gboolean isset_row = FALSE;
  gboolean isset_family = FALSE;
  gboolean isset_qualifier = FALSE;
  gboolean isset_tdelete = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->family != NULL)
          {
            g_free(this_object->family);
            this_object->family = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->family = g_byte_array_new();
          g_byte_array_append (this_object->family, (guint8 *) data, (guint) len);
          g_free (data);
          isset_family = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->qualifier != NULL)
          {
            g_free(this_object->qualifier);
            this_object->qualifier = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->qualifier = g_byte_array_new();
          g_byte_array_append (this_object->qualifier, (guint8 *) data, (guint) len);
          g_free (data);
          isset_qualifier = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->value = g_byte_array_new();
          g_byte_array_append (this_object->value, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tdelete), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_tdelete = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_table)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_row)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_family)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_qualifier)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_tdelete)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_check_and_delete_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceCheckAndDeleteArgs * this_object = T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceCheckAndDeleteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "family", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->family ? ((GByteArray *) this_object->family)->data : NULL, this_object->family ? ((GByteArray *) this_object->family)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "qualifier", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->qualifier ? ((GByteArray *) this_object->qualifier)->data : NULL, this_object->qualifier ? ((GByteArray *) this_object->qualifier)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->value ? ((GByteArray *) this_object->value)->data : NULL, this_object->value ? ((GByteArray *) this_object->value)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tdelete", T_STRUCT, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tdelete), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_check_and_delete_args_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  THBaseServiceCheckAndDeleteArgs *self = T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_FAMILY:
      if (self->family != NULL)
        g_byte_array_unref (self->family);
      self->family = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_QUALIFIER:
      if (self->qualifier != NULL)
        g_byte_array_unref (self->qualifier);
      self->qualifier = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_VALUE:
      if (self->value != NULL)
        g_byte_array_unref (self->value);
      self->value = g_value_dup_boxed (value);
      self->__isset_value = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_TDELETE:
      if (self->tdelete != NULL)
        g_object_unref (self->tdelete);
      self->tdelete = g_value_dup_object (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_check_and_delete_args_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  THBaseServiceCheckAndDeleteArgs *self = T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_FAMILY:
      g_value_set_boxed (value, self->family);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_QUALIFIER:
      g_value_set_boxed (value, self->qualifier);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_VALUE:
      g_value_set_boxed (value, self->value);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_TDELETE:
      g_value_set_object (value, self->tdelete);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_check_and_delete_args_instance_init (THBaseServiceCheckAndDeleteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
  object->row = NULL;
  object->family = NULL;
  object->qualifier = NULL;
  object->value = NULL;
  object->__isset_value = FALSE;
  object->tdelete = g_object_new (TYPE_T_DELETE, NULL);
}

static void 
t_h_base_service_check_and_delete_args_finalize (GObject *object)
{
  THBaseServiceCheckAndDeleteArgs *tobject = T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->family != NULL)
  {
    thrift_string_free(tobject->family);
    tobject->family = NULL;
  }
  if (tobject->qualifier != NULL)
  {
    thrift_string_free(tobject->qualifier);
    tobject->qualifier = NULL;
  }
  if (tobject->value != NULL)
  {
    thrift_string_free(tobject->value);
    tobject->value = NULL;
  }
  if (tobject->tdelete != NULL)
  {
    g_object_unref(tobject->tdelete);
    tobject->tdelete = NULL;
  }
}

static void
t_h_base_service_check_and_delete_args_class_init (THBaseServiceCheckAndDeleteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_check_and_delete_args_read;
  struct_class->write = t_h_base_service_check_and_delete_args_write;

  gobject_class->finalize = t_h_base_service_check_and_delete_args_finalize;
  gobject_class->get_property = t_h_base_service_check_and_delete_args_get_property;
  gobject_class->set_property = t_h_base_service_check_and_delete_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_FAMILY,
     g_param_spec_boxed ("family",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_QUALIFIER,
     g_param_spec_boxed ("qualifier",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_VALUE,
     g_param_spec_boxed ("value",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_ARGS_TDELETE,
     g_param_spec_object ("tdelete",
                         NULL,
                         NULL,
                         TYPE_T_DELETE,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_check_and_delete_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceCheckAndDeleteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_check_and_delete_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceCheckAndDeleteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_check_and_delete_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceCheckAndDeleteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceCheckAndDeleteResultProperties
{
  PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_RESULT_0,
  PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_RESULT_SUCCESS,
  PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_RESULT_IO
};

/* reads a t_h_base_service_check_and_delete_result object */
static gint32
t_h_base_service_check_and_delete_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceCheckAndDeleteResult * this_object = T_H_BASE_SERVICE_CHECK_AND_DELETE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_check_and_delete_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceCheckAndDeleteResult * this_object = T_H_BASE_SERVICE_CHECK_AND_DELETE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceCheckAndDeleteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_check_and_delete_result_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  THBaseServiceCheckAndDeleteResult *self = T_H_BASE_SERVICE_CHECK_AND_DELETE_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_check_and_delete_result_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  THBaseServiceCheckAndDeleteResult *self = T_H_BASE_SERVICE_CHECK_AND_DELETE_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_check_and_delete_result_instance_init (THBaseServiceCheckAndDeleteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
t_h_base_service_check_and_delete_result_finalize (GObject *object)
{
  THBaseServiceCheckAndDeleteResult *tobject = T_H_BASE_SERVICE_CHECK_AND_DELETE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
t_h_base_service_check_and_delete_result_class_init (THBaseServiceCheckAndDeleteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_check_and_delete_result_read;
  struct_class->write = t_h_base_service_check_and_delete_result_write;

  gobject_class->finalize = t_h_base_service_check_and_delete_result_finalize;
  gobject_class->get_property = t_h_base_service_check_and_delete_result_get_property;
  gobject_class->set_property = t_h_base_service_check_and_delete_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_DELETE_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_check_and_delete_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceCheckAndDeleteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_check_and_delete_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceCheckAndDeleteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_check_and_delete_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceCheckAndDeleteResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceIncrementArgsProperties
{
  PROP_T_H_BASE_SERVICE_INCREMENT_ARGS_0,
  PROP_T_H_BASE_SERVICE_INCREMENT_ARGS_TABLE,
  PROP_T_H_BASE_SERVICE_INCREMENT_ARGS_TINCREMENT
};

/* reads a t_h_base_service_increment_args object */
static gint32
t_h_base_service_increment_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceIncrementArgs * this_object = T_H_BASE_SERVICE_INCREMENT_ARGS(object);
  gboolean isset_table = FALSE;
  gboolean isset_tincrement = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tincrement), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_tincrement = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_table)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_tincrement)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_increment_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceIncrementArgs * this_object = T_H_BASE_SERVICE_INCREMENT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceIncrementArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tincrement", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tincrement), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_increment_args_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  THBaseServiceIncrementArgs *self = T_H_BASE_SERVICE_INCREMENT_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_INCREMENT_ARGS_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_INCREMENT_ARGS_TINCREMENT:
      if (self->tincrement != NULL)
        g_object_unref (self->tincrement);
      self->tincrement = g_value_dup_object (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_increment_args_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  THBaseServiceIncrementArgs *self = T_H_BASE_SERVICE_INCREMENT_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_INCREMENT_ARGS_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    case PROP_T_H_BASE_SERVICE_INCREMENT_ARGS_TINCREMENT:
      g_value_set_object (value, self->tincrement);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_increment_args_instance_init (THBaseServiceIncrementArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
  object->tincrement = g_object_new (TYPE_T_INCREMENT, NULL);
}

static void 
t_h_base_service_increment_args_finalize (GObject *object)
{
  THBaseServiceIncrementArgs *tobject = T_H_BASE_SERVICE_INCREMENT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->tincrement != NULL)
  {
    g_object_unref(tobject->tincrement);
    tobject->tincrement = NULL;
  }
}

static void
t_h_base_service_increment_args_class_init (THBaseServiceIncrementArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_increment_args_read;
  struct_class->write = t_h_base_service_increment_args_write;

  gobject_class->finalize = t_h_base_service_increment_args_finalize;
  gobject_class->get_property = t_h_base_service_increment_args_get_property;
  gobject_class->set_property = t_h_base_service_increment_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_INCREMENT_ARGS_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_INCREMENT_ARGS_TINCREMENT,
     g_param_spec_object ("tincrement",
                         NULL,
                         NULL,
                         TYPE_T_INCREMENT,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_increment_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceIncrementArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_increment_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceIncrementArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_increment_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceIncrementArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceIncrementResultProperties
{
  PROP_T_H_BASE_SERVICE_INCREMENT_RESULT_0,
  PROP_T_H_BASE_SERVICE_INCREMENT_RESULT_SUCCESS,
  PROP_T_H_BASE_SERVICE_INCREMENT_RESULT_IO
};

/* reads a t_h_base_service_increment_result object */
static gint32
t_h_base_service_increment_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceIncrementResult * this_object = T_H_BASE_SERVICE_INCREMENT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_increment_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceIncrementResult * this_object = T_H_BASE_SERVICE_INCREMENT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceIncrementResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_increment_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  THBaseServiceIncrementResult *self = T_H_BASE_SERVICE_INCREMENT_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_INCREMENT_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_INCREMENT_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_increment_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  THBaseServiceIncrementResult *self = T_H_BASE_SERVICE_INCREMENT_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_INCREMENT_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_T_H_BASE_SERVICE_INCREMENT_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_increment_result_instance_init (THBaseServiceIncrementResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_T_RESULT, NULL);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
t_h_base_service_increment_result_finalize (GObject *object)
{
  THBaseServiceIncrementResult *tobject = T_H_BASE_SERVICE_INCREMENT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
t_h_base_service_increment_result_class_init (THBaseServiceIncrementResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_increment_result_read;
  struct_class->write = t_h_base_service_increment_result_write;

  gobject_class->finalize = t_h_base_service_increment_result_finalize;
  gobject_class->get_property = t_h_base_service_increment_result_get_property;
  gobject_class->set_property = t_h_base_service_increment_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_INCREMENT_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_T_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_INCREMENT_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_increment_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceIncrementResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_increment_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceIncrementResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_increment_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceIncrementResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceAppendArgsProperties
{
  PROP_T_H_BASE_SERVICE_APPEND_ARGS_0,
  PROP_T_H_BASE_SERVICE_APPEND_ARGS_TABLE,
  PROP_T_H_BASE_SERVICE_APPEND_ARGS_TAPPEND
};

/* reads a t_h_base_service_append_args object */
static gint32
t_h_base_service_append_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceAppendArgs * this_object = T_H_BASE_SERVICE_APPEND_ARGS(object);
  gboolean isset_table = FALSE;
  gboolean isset_tappend = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tappend), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_tappend = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_table)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_tappend)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_append_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceAppendArgs * this_object = T_H_BASE_SERVICE_APPEND_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceAppendArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tappend", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tappend), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_append_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  THBaseServiceAppendArgs *self = T_H_BASE_SERVICE_APPEND_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_APPEND_ARGS_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_APPEND_ARGS_TAPPEND:
      if (self->tappend != NULL)
        g_object_unref (self->tappend);
      self->tappend = g_value_dup_object (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_append_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  THBaseServiceAppendArgs *self = T_H_BASE_SERVICE_APPEND_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_APPEND_ARGS_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    case PROP_T_H_BASE_SERVICE_APPEND_ARGS_TAPPEND:
      g_value_set_object (value, self->tappend);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_append_args_instance_init (THBaseServiceAppendArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
  object->tappend = g_object_new (TYPE_T_APPEND, NULL);
}

static void 
t_h_base_service_append_args_finalize (GObject *object)
{
  THBaseServiceAppendArgs *tobject = T_H_BASE_SERVICE_APPEND_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->tappend != NULL)
  {
    g_object_unref(tobject->tappend);
    tobject->tappend = NULL;
  }
}

static void
t_h_base_service_append_args_class_init (THBaseServiceAppendArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_append_args_read;
  struct_class->write = t_h_base_service_append_args_write;

  gobject_class->finalize = t_h_base_service_append_args_finalize;
  gobject_class->get_property = t_h_base_service_append_args_get_property;
  gobject_class->set_property = t_h_base_service_append_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_APPEND_ARGS_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_APPEND_ARGS_TAPPEND,
     g_param_spec_object ("tappend",
                         NULL,
                         NULL,
                         TYPE_T_APPEND,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_append_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceAppendArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_append_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceAppendArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_append_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceAppendArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceAppendResultProperties
{
  PROP_T_H_BASE_SERVICE_APPEND_RESULT_0,
  PROP_T_H_BASE_SERVICE_APPEND_RESULT_SUCCESS,
  PROP_T_H_BASE_SERVICE_APPEND_RESULT_IO
};

/* reads a t_h_base_service_append_result object */
static gint32
t_h_base_service_append_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceAppendResult * this_object = T_H_BASE_SERVICE_APPEND_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_append_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceAppendResult * this_object = T_H_BASE_SERVICE_APPEND_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceAppendResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_append_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  THBaseServiceAppendResult *self = T_H_BASE_SERVICE_APPEND_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_APPEND_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_APPEND_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_append_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  THBaseServiceAppendResult *self = T_H_BASE_SERVICE_APPEND_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_APPEND_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_T_H_BASE_SERVICE_APPEND_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_append_result_instance_init (THBaseServiceAppendResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_T_RESULT, NULL);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
t_h_base_service_append_result_finalize (GObject *object)
{
  THBaseServiceAppendResult *tobject = T_H_BASE_SERVICE_APPEND_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
t_h_base_service_append_result_class_init (THBaseServiceAppendResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_append_result_read;
  struct_class->write = t_h_base_service_append_result_write;

  gobject_class->finalize = t_h_base_service_append_result_finalize;
  gobject_class->get_property = t_h_base_service_append_result_get_property;
  gobject_class->set_property = t_h_base_service_append_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_APPEND_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_T_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_APPEND_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_append_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceAppendResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_append_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceAppendResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_append_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceAppendResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceOpenScannerArgsProperties
{
  PROP_T_H_BASE_SERVICE_OPEN_SCANNER_ARGS_0,
  PROP_T_H_BASE_SERVICE_OPEN_SCANNER_ARGS_TABLE,
  PROP_T_H_BASE_SERVICE_OPEN_SCANNER_ARGS_TSCAN
};

/* reads a t_h_base_service_open_scanner_args object */
static gint32
t_h_base_service_open_scanner_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceOpenScannerArgs * this_object = T_H_BASE_SERVICE_OPEN_SCANNER_ARGS(object);
  gboolean isset_table = FALSE;
  gboolean isset_tscan = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tscan), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_tscan = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_table)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_tscan)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_open_scanner_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceOpenScannerArgs * this_object = T_H_BASE_SERVICE_OPEN_SCANNER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceOpenScannerArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tscan", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tscan), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_open_scanner_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  THBaseServiceOpenScannerArgs *self = T_H_BASE_SERVICE_OPEN_SCANNER_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_OPEN_SCANNER_ARGS_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_OPEN_SCANNER_ARGS_TSCAN:
      if (self->tscan != NULL)
        g_object_unref (self->tscan);
      self->tscan = g_value_dup_object (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_open_scanner_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  THBaseServiceOpenScannerArgs *self = T_H_BASE_SERVICE_OPEN_SCANNER_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_OPEN_SCANNER_ARGS_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    case PROP_T_H_BASE_SERVICE_OPEN_SCANNER_ARGS_TSCAN:
      g_value_set_object (value, self->tscan);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_open_scanner_args_instance_init (THBaseServiceOpenScannerArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
  object->tscan = g_object_new (TYPE_T_SCAN, NULL);
}

static void 
t_h_base_service_open_scanner_args_finalize (GObject *object)
{
  THBaseServiceOpenScannerArgs *tobject = T_H_BASE_SERVICE_OPEN_SCANNER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->tscan != NULL)
  {
    g_object_unref(tobject->tscan);
    tobject->tscan = NULL;
  }
}

static void
t_h_base_service_open_scanner_args_class_init (THBaseServiceOpenScannerArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_open_scanner_args_read;
  struct_class->write = t_h_base_service_open_scanner_args_write;

  gobject_class->finalize = t_h_base_service_open_scanner_args_finalize;
  gobject_class->get_property = t_h_base_service_open_scanner_args_get_property;
  gobject_class->set_property = t_h_base_service_open_scanner_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_OPEN_SCANNER_ARGS_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_OPEN_SCANNER_ARGS_TSCAN,
     g_param_spec_object ("tscan",
                         NULL,
                         NULL,
                         TYPE_T_SCAN,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_open_scanner_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceOpenScannerArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_open_scanner_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceOpenScannerArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_open_scanner_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceOpenScannerArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceOpenScannerResultProperties
{
  PROP_T_H_BASE_SERVICE_OPEN_SCANNER_RESULT_0,
  PROP_T_H_BASE_SERVICE_OPEN_SCANNER_RESULT_SUCCESS,
  PROP_T_H_BASE_SERVICE_OPEN_SCANNER_RESULT_IO
};

/* reads a t_h_base_service_open_scanner_result object */
static gint32
t_h_base_service_open_scanner_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceOpenScannerResult * this_object = T_H_BASE_SERVICE_OPEN_SCANNER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_open_scanner_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceOpenScannerResult * this_object = T_H_BASE_SERVICE_OPEN_SCANNER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceOpenScannerResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_open_scanner_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  THBaseServiceOpenScannerResult *self = T_H_BASE_SERVICE_OPEN_SCANNER_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_OPEN_SCANNER_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_OPEN_SCANNER_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_open_scanner_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  THBaseServiceOpenScannerResult *self = T_H_BASE_SERVICE_OPEN_SCANNER_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_OPEN_SCANNER_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_T_H_BASE_SERVICE_OPEN_SCANNER_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_open_scanner_result_instance_init (THBaseServiceOpenScannerResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
t_h_base_service_open_scanner_result_finalize (GObject *object)
{
  THBaseServiceOpenScannerResult *tobject = T_H_BASE_SERVICE_OPEN_SCANNER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
t_h_base_service_open_scanner_result_class_init (THBaseServiceOpenScannerResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_open_scanner_result_read;
  struct_class->write = t_h_base_service_open_scanner_result_write;

  gobject_class->finalize = t_h_base_service_open_scanner_result_finalize;
  gobject_class->get_property = t_h_base_service_open_scanner_result_get_property;
  gobject_class->set_property = t_h_base_service_open_scanner_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_OPEN_SCANNER_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_OPEN_SCANNER_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_open_scanner_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceOpenScannerResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_open_scanner_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceOpenScannerResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_open_scanner_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceOpenScannerResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceGetScannerRowsArgsProperties
{
  PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_ARGS_0,
  PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_ARGS_SCANNER_ID,
  PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_ARGS_NUM_ROWS
};

/* reads a t_h_base_service_get_scanner_rows_args object */
static gint32
t_h_base_service_get_scanner_rows_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceGetScannerRowsArgs * this_object = T_H_BASE_SERVICE_GET_SCANNER_ROWS_ARGS(object);
  gboolean isset_scannerId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->scannerId, error)) < 0)
            return -1;
          xfer += ret;
          isset_scannerId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->numRows, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_numRows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_scannerId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_get_scanner_rows_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceGetScannerRowsArgs * this_object = T_H_BASE_SERVICE_GET_SCANNER_ROWS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceGetScannerRowsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "scannerId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->scannerId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "numRows", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->numRows, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_get_scanner_rows_args_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  THBaseServiceGetScannerRowsArgs *self = T_H_BASE_SERVICE_GET_SCANNER_ROWS_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_ARGS_SCANNER_ID:
      self->scannerId = g_value_get_int (value);
      break;

    case PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_ARGS_NUM_ROWS:
      self->numRows = g_value_get_int (value);
      self->__isset_numRows = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_get_scanner_rows_args_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  THBaseServiceGetScannerRowsArgs *self = T_H_BASE_SERVICE_GET_SCANNER_ROWS_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_ARGS_SCANNER_ID:
      g_value_set_int (value, self->scannerId);
      break;

    case PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_ARGS_NUM_ROWS:
      g_value_set_int (value, self->numRows);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_get_scanner_rows_args_instance_init (THBaseServiceGetScannerRowsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->scannerId = 0;
  object->numRows = 1;
  object->__isset_numRows = FALSE;
}

static void 
t_h_base_service_get_scanner_rows_args_finalize (GObject *object)
{
  THBaseServiceGetScannerRowsArgs *tobject = T_H_BASE_SERVICE_GET_SCANNER_ROWS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_h_base_service_get_scanner_rows_args_class_init (THBaseServiceGetScannerRowsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_get_scanner_rows_args_read;
  struct_class->write = t_h_base_service_get_scanner_rows_args_write;

  gobject_class->finalize = t_h_base_service_get_scanner_rows_args_finalize;
  gobject_class->get_property = t_h_base_service_get_scanner_rows_args_get_property;
  gobject_class->set_property = t_h_base_service_get_scanner_rows_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_ARGS_SCANNER_ID,
     g_param_spec_int ("scannerId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_ARGS_NUM_ROWS,
     g_param_spec_int ("numRows",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       1,
                       G_PARAM_READWRITE));
}

GType
t_h_base_service_get_scanner_rows_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceGetScannerRowsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_get_scanner_rows_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceGetScannerRowsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_get_scanner_rows_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceGetScannerRowsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceGetScannerRowsResultProperties
{
  PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_RESULT_0,
  PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_RESULT_SUCCESS,
  PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_RESULT_IO,
  PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_RESULT_IA
};

/* reads a t_h_base_service_get_scanner_rows_result object */
static gint32
t_h_base_service_get_scanner_rows_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceGetScannerRowsResult * this_object = T_H_BASE_SERVICE_GET_SCANNER_ROWS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TResult * _elem65 = NULL;
              if ( _elem65 != NULL)
              {
                g_object_unref (_elem65);
              }
              _elem65 = g_object_new (TYPE_T_RESULT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem65), protocol, error)) < 0)
              {
                g_object_unref (_elem65);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem65);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ia != NULL)
          {
            g_object_unref (this_object->ia);
          }
          this_object->ia = g_object_new (TYPE_T_ILLEGAL_ARGUMENT, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
          {
            g_object_unref (this_object->ia);
            this_object->ia = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ia = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_get_scanner_rows_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceGetScannerRowsResult * this_object = T_H_BASE_SERVICE_GET_SCANNER_ROWS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceGetScannerRowsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i66;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i66 = 0; i66 < (this_object->success ? this_object->success->len : 0); i66++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i66))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ia == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ia", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_get_scanner_rows_result_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  THBaseServiceGetScannerRowsResult *self = T_H_BASE_SERVICE_GET_SCANNER_ROWS_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_RESULT_IA:
      if (self->ia != NULL)
        g_object_unref (self->ia);
      self->ia = g_value_dup_object (value);
      self->__isset_ia = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_get_scanner_rows_result_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  THBaseServiceGetScannerRowsResult *self = T_H_BASE_SERVICE_GET_SCANNER_ROWS_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    case PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_RESULT_IA:
      g_value_set_object (value, self->ia);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_get_scanner_rows_result_instance_init (THBaseServiceGetScannerRowsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
  object->ia = NULL;
  object->__isset_ia = FALSE;
}

static void 
t_h_base_service_get_scanner_rows_result_finalize (GObject *object)
{
  THBaseServiceGetScannerRowsResult *tobject = T_H_BASE_SERVICE_GET_SCANNER_ROWS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
  if (tobject->ia != NULL)
  {
    g_object_unref(tobject->ia);
    tobject->ia = NULL;
  }
}

static void
t_h_base_service_get_scanner_rows_result_class_init (THBaseServiceGetScannerRowsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_get_scanner_rows_result_read;
  struct_class->write = t_h_base_service_get_scanner_rows_result_write;

  gobject_class->finalize = t_h_base_service_get_scanner_rows_result_finalize;
  gobject_class->get_property = t_h_base_service_get_scanner_rows_result_get_property;
  gobject_class->set_property = t_h_base_service_get_scanner_rows_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_SCANNER_ROWS_RESULT_IA,
     g_param_spec_object ("ia",
                         NULL,
                         NULL,
                         TYPE_T_ILLEGAL_ARGUMENT,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_get_scanner_rows_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceGetScannerRowsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_get_scanner_rows_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceGetScannerRowsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_get_scanner_rows_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceGetScannerRowsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceCloseScannerArgsProperties
{
  PROP_T_H_BASE_SERVICE_CLOSE_SCANNER_ARGS_0,
  PROP_T_H_BASE_SERVICE_CLOSE_SCANNER_ARGS_SCANNER_ID
};

/* reads a t_h_base_service_close_scanner_args object */
static gint32
t_h_base_service_close_scanner_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceCloseScannerArgs * this_object = T_H_BASE_SERVICE_CLOSE_SCANNER_ARGS(object);
  gboolean isset_scannerId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->scannerId, error)) < 0)
            return -1;
          xfer += ret;
          isset_scannerId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_scannerId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_close_scanner_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceCloseScannerArgs * this_object = T_H_BASE_SERVICE_CLOSE_SCANNER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceCloseScannerArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "scannerId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->scannerId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_close_scanner_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  THBaseServiceCloseScannerArgs *self = T_H_BASE_SERVICE_CLOSE_SCANNER_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_CLOSE_SCANNER_ARGS_SCANNER_ID:
      self->scannerId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_close_scanner_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  THBaseServiceCloseScannerArgs *self = T_H_BASE_SERVICE_CLOSE_SCANNER_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_CLOSE_SCANNER_ARGS_SCANNER_ID:
      g_value_set_int (value, self->scannerId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_close_scanner_args_instance_init (THBaseServiceCloseScannerArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->scannerId = 0;
}

static void 
t_h_base_service_close_scanner_args_finalize (GObject *object)
{
  THBaseServiceCloseScannerArgs *tobject = T_H_BASE_SERVICE_CLOSE_SCANNER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
t_h_base_service_close_scanner_args_class_init (THBaseServiceCloseScannerArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_close_scanner_args_read;
  struct_class->write = t_h_base_service_close_scanner_args_write;

  gobject_class->finalize = t_h_base_service_close_scanner_args_finalize;
  gobject_class->get_property = t_h_base_service_close_scanner_args_get_property;
  gobject_class->set_property = t_h_base_service_close_scanner_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CLOSE_SCANNER_ARGS_SCANNER_ID,
     g_param_spec_int ("scannerId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_h_base_service_close_scanner_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceCloseScannerArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_close_scanner_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceCloseScannerArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_close_scanner_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceCloseScannerArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceCloseScannerResultProperties
{
  PROP_T_H_BASE_SERVICE_CLOSE_SCANNER_RESULT_0,
  PROP_T_H_BASE_SERVICE_CLOSE_SCANNER_RESULT_IO,
  PROP_T_H_BASE_SERVICE_CLOSE_SCANNER_RESULT_IA
};

/* reads a t_h_base_service_close_scanner_result object */
static gint32
t_h_base_service_close_scanner_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceCloseScannerResult * this_object = T_H_BASE_SERVICE_CLOSE_SCANNER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ia != NULL)
          {
            g_object_unref (this_object->ia);
          }
          this_object->ia = g_object_new (TYPE_T_ILLEGAL_ARGUMENT, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
          {
            g_object_unref (this_object->ia);
            this_object->ia = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ia = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_close_scanner_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceCloseScannerResult * this_object = T_H_BASE_SERVICE_CLOSE_SCANNER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceCloseScannerResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ia == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ia", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_close_scanner_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  THBaseServiceCloseScannerResult *self = T_H_BASE_SERVICE_CLOSE_SCANNER_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_CLOSE_SCANNER_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_CLOSE_SCANNER_RESULT_IA:
      if (self->ia != NULL)
        g_object_unref (self->ia);
      self->ia = g_value_dup_object (value);
      self->__isset_ia = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_close_scanner_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  THBaseServiceCloseScannerResult *self = T_H_BASE_SERVICE_CLOSE_SCANNER_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_CLOSE_SCANNER_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    case PROP_T_H_BASE_SERVICE_CLOSE_SCANNER_RESULT_IA:
      g_value_set_object (value, self->ia);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_close_scanner_result_instance_init (THBaseServiceCloseScannerResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
  object->ia = NULL;
  object->__isset_ia = FALSE;
}

static void 
t_h_base_service_close_scanner_result_finalize (GObject *object)
{
  THBaseServiceCloseScannerResult *tobject = T_H_BASE_SERVICE_CLOSE_SCANNER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
  if (tobject->ia != NULL)
  {
    g_object_unref(tobject->ia);
    tobject->ia = NULL;
  }
}

static void
t_h_base_service_close_scanner_result_class_init (THBaseServiceCloseScannerResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_close_scanner_result_read;
  struct_class->write = t_h_base_service_close_scanner_result_write;

  gobject_class->finalize = t_h_base_service_close_scanner_result_finalize;
  gobject_class->get_property = t_h_base_service_close_scanner_result_get_property;
  gobject_class->set_property = t_h_base_service_close_scanner_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CLOSE_SCANNER_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CLOSE_SCANNER_RESULT_IA,
     g_param_spec_object ("ia",
                         NULL,
                         NULL,
                         TYPE_T_ILLEGAL_ARGUMENT,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_close_scanner_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceCloseScannerResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_close_scanner_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceCloseScannerResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_close_scanner_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceCloseScannerResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceMutateRowArgsProperties
{
  PROP_T_H_BASE_SERVICE_MUTATE_ROW_ARGS_0,
  PROP_T_H_BASE_SERVICE_MUTATE_ROW_ARGS_TABLE,
  PROP_T_H_BASE_SERVICE_MUTATE_ROW_ARGS_TROW_MUTATIONS
};

/* reads a t_h_base_service_mutate_row_args object */
static gint32
t_h_base_service_mutate_row_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceMutateRowArgs * this_object = T_H_BASE_SERVICE_MUTATE_ROW_ARGS(object);
  gboolean isset_table = FALSE;
  gboolean isset_trowMutations = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->trowMutations), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_trowMutations = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_table)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_trowMutations)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_mutate_row_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceMutateRowArgs * this_object = T_H_BASE_SERVICE_MUTATE_ROW_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceMutateRowArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "trowMutations", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->trowMutations), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_mutate_row_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  THBaseServiceMutateRowArgs *self = T_H_BASE_SERVICE_MUTATE_ROW_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_MUTATE_ROW_ARGS_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_MUTATE_ROW_ARGS_TROW_MUTATIONS:
      if (self->trowMutations != NULL)
        g_object_unref (self->trowMutations);
      self->trowMutations = g_value_dup_object (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_mutate_row_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  THBaseServiceMutateRowArgs *self = T_H_BASE_SERVICE_MUTATE_ROW_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_MUTATE_ROW_ARGS_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    case PROP_T_H_BASE_SERVICE_MUTATE_ROW_ARGS_TROW_MUTATIONS:
      g_value_set_object (value, self->trowMutations);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_mutate_row_args_instance_init (THBaseServiceMutateRowArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
  object->trowMutations = g_object_new (TYPE_T_ROW_MUTATIONS, NULL);
}

static void 
t_h_base_service_mutate_row_args_finalize (GObject *object)
{
  THBaseServiceMutateRowArgs *tobject = T_H_BASE_SERVICE_MUTATE_ROW_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->trowMutations != NULL)
  {
    g_object_unref(tobject->trowMutations);
    tobject->trowMutations = NULL;
  }
}

static void
t_h_base_service_mutate_row_args_class_init (THBaseServiceMutateRowArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_mutate_row_args_read;
  struct_class->write = t_h_base_service_mutate_row_args_write;

  gobject_class->finalize = t_h_base_service_mutate_row_args_finalize;
  gobject_class->get_property = t_h_base_service_mutate_row_args_get_property;
  gobject_class->set_property = t_h_base_service_mutate_row_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_MUTATE_ROW_ARGS_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_MUTATE_ROW_ARGS_TROW_MUTATIONS,
     g_param_spec_object ("trowMutations",
                         NULL,
                         NULL,
                         TYPE_T_ROW_MUTATIONS,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_mutate_row_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceMutateRowArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_mutate_row_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceMutateRowArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_mutate_row_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceMutateRowArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceMutateRowResultProperties
{
  PROP_T_H_BASE_SERVICE_MUTATE_ROW_RESULT_0,
  PROP_T_H_BASE_SERVICE_MUTATE_ROW_RESULT_IO
};

/* reads a t_h_base_service_mutate_row_result object */
static gint32
t_h_base_service_mutate_row_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceMutateRowResult * this_object = T_H_BASE_SERVICE_MUTATE_ROW_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_mutate_row_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceMutateRowResult * this_object = T_H_BASE_SERVICE_MUTATE_ROW_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceMutateRowResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_mutate_row_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  THBaseServiceMutateRowResult *self = T_H_BASE_SERVICE_MUTATE_ROW_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_MUTATE_ROW_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_mutate_row_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  THBaseServiceMutateRowResult *self = T_H_BASE_SERVICE_MUTATE_ROW_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_MUTATE_ROW_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_mutate_row_result_instance_init (THBaseServiceMutateRowResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
t_h_base_service_mutate_row_result_finalize (GObject *object)
{
  THBaseServiceMutateRowResult *tobject = T_H_BASE_SERVICE_MUTATE_ROW_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
t_h_base_service_mutate_row_result_class_init (THBaseServiceMutateRowResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_mutate_row_result_read;
  struct_class->write = t_h_base_service_mutate_row_result_write;

  gobject_class->finalize = t_h_base_service_mutate_row_result_finalize;
  gobject_class->get_property = t_h_base_service_mutate_row_result_get_property;
  gobject_class->set_property = t_h_base_service_mutate_row_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_MUTATE_ROW_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_mutate_row_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceMutateRowResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_mutate_row_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceMutateRowResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_mutate_row_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceMutateRowResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceGetScannerResultsArgsProperties
{
  PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_ARGS_0,
  PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_ARGS_TABLE,
  PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_ARGS_TSCAN,
  PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_ARGS_NUM_ROWS
};

/* reads a t_h_base_service_get_scanner_results_args object */
static gint32
t_h_base_service_get_scanner_results_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceGetScannerResultsArgs * this_object = T_H_BASE_SERVICE_GET_SCANNER_RESULTS_ARGS(object);
  gboolean isset_table = FALSE;
  gboolean isset_tscan = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tscan), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_tscan = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->numRows, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_numRows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_table)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_tscan)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_get_scanner_results_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceGetScannerResultsArgs * this_object = T_H_BASE_SERVICE_GET_SCANNER_RESULTS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceGetScannerResultsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tscan", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tscan), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "numRows", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->numRows, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_get_scanner_results_args_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  THBaseServiceGetScannerResultsArgs *self = T_H_BASE_SERVICE_GET_SCANNER_RESULTS_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_ARGS_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_ARGS_TSCAN:
      if (self->tscan != NULL)
        g_object_unref (self->tscan);
      self->tscan = g_value_dup_object (value);
      break;

    case PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_ARGS_NUM_ROWS:
      self->numRows = g_value_get_int (value);
      self->__isset_numRows = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_get_scanner_results_args_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  THBaseServiceGetScannerResultsArgs *self = T_H_BASE_SERVICE_GET_SCANNER_RESULTS_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_ARGS_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    case PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_ARGS_TSCAN:
      g_value_set_object (value, self->tscan);
      break;

    case PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_ARGS_NUM_ROWS:
      g_value_set_int (value, self->numRows);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_get_scanner_results_args_instance_init (THBaseServiceGetScannerResultsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
  object->tscan = g_object_new (TYPE_T_SCAN, NULL);
  object->numRows = 1;
  object->__isset_numRows = FALSE;
}

static void 
t_h_base_service_get_scanner_results_args_finalize (GObject *object)
{
  THBaseServiceGetScannerResultsArgs *tobject = T_H_BASE_SERVICE_GET_SCANNER_RESULTS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->tscan != NULL)
  {
    g_object_unref(tobject->tscan);
    tobject->tscan = NULL;
  }
}

static void
t_h_base_service_get_scanner_results_args_class_init (THBaseServiceGetScannerResultsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_get_scanner_results_args_read;
  struct_class->write = t_h_base_service_get_scanner_results_args_write;

  gobject_class->finalize = t_h_base_service_get_scanner_results_args_finalize;
  gobject_class->get_property = t_h_base_service_get_scanner_results_args_get_property;
  gobject_class->set_property = t_h_base_service_get_scanner_results_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_ARGS_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_ARGS_TSCAN,
     g_param_spec_object ("tscan",
                         NULL,
                         NULL,
                         TYPE_T_SCAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_ARGS_NUM_ROWS,
     g_param_spec_int ("numRows",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       1,
                       G_PARAM_READWRITE));
}

GType
t_h_base_service_get_scanner_results_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceGetScannerResultsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_get_scanner_results_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceGetScannerResultsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_get_scanner_results_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceGetScannerResultsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceGetScannerResultsResultProperties
{
  PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_RESULT_0,
  PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_RESULT_SUCCESS,
  PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_RESULT_IO
};

/* reads a t_h_base_service_get_scanner_results_result object */
static gint32
t_h_base_service_get_scanner_results_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceGetScannerResultsResult * this_object = T_H_BASE_SERVICE_GET_SCANNER_RESULTS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TResult * _elem67 = NULL;
              if ( _elem67 != NULL)
              {
                g_object_unref (_elem67);
              }
              _elem67 = g_object_new (TYPE_T_RESULT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem67), protocol, error)) < 0)
              {
                g_object_unref (_elem67);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem67);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_get_scanner_results_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceGetScannerResultsResult * this_object = T_H_BASE_SERVICE_GET_SCANNER_RESULTS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceGetScannerResultsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i68;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i68 = 0; i68 < (this_object->success ? this_object->success->len : 0); i68++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i68))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_get_scanner_results_result_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  THBaseServiceGetScannerResultsResult *self = T_H_BASE_SERVICE_GET_SCANNER_RESULTS_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_get_scanner_results_result_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  THBaseServiceGetScannerResultsResult *self = T_H_BASE_SERVICE_GET_SCANNER_RESULTS_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_get_scanner_results_result_instance_init (THBaseServiceGetScannerResultsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
t_h_base_service_get_scanner_results_result_finalize (GObject *object)
{
  THBaseServiceGetScannerResultsResult *tobject = T_H_BASE_SERVICE_GET_SCANNER_RESULTS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
t_h_base_service_get_scanner_results_result_class_init (THBaseServiceGetScannerResultsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_get_scanner_results_result_read;
  struct_class->write = t_h_base_service_get_scanner_results_result_write;

  gobject_class->finalize = t_h_base_service_get_scanner_results_result_finalize;
  gobject_class->get_property = t_h_base_service_get_scanner_results_result_get_property;
  gobject_class->set_property = t_h_base_service_get_scanner_results_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_SCANNER_RESULTS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_get_scanner_results_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceGetScannerResultsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_get_scanner_results_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceGetScannerResultsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_get_scanner_results_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceGetScannerResultsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceGetRegionLocationArgsProperties
{
  PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_ARGS_0,
  PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_ARGS_TABLE,
  PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_ARGS_ROW,
  PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_ARGS_RELOAD
};

/* reads a t_h_base_service_get_region_location_args object */
static gint32
t_h_base_service_get_region_location_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceGetRegionLocationArgs * this_object = T_H_BASE_SERVICE_GET_REGION_LOCATION_ARGS(object);
  gboolean isset_table = FALSE;
  gboolean isset_row = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->reload, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_reload = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_table)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_row)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_get_region_location_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceGetRegionLocationArgs * this_object = T_H_BASE_SERVICE_GET_REGION_LOCATION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceGetRegionLocationArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "reload", T_BOOL, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->reload, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_get_region_location_args_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  THBaseServiceGetRegionLocationArgs *self = T_H_BASE_SERVICE_GET_REGION_LOCATION_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_ARGS_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_ARGS_RELOAD:
      self->reload = g_value_get_boolean (value);
      self->__isset_reload = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_get_region_location_args_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  THBaseServiceGetRegionLocationArgs *self = T_H_BASE_SERVICE_GET_REGION_LOCATION_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_ARGS_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    case PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_ARGS_RELOAD:
      g_value_set_boolean (value, self->reload);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_get_region_location_args_instance_init (THBaseServiceGetRegionLocationArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
  object->row = NULL;
  object->reload = 0;
  object->__isset_reload = FALSE;
}

static void 
t_h_base_service_get_region_location_args_finalize (GObject *object)
{
  THBaseServiceGetRegionLocationArgs *tobject = T_H_BASE_SERVICE_GET_REGION_LOCATION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
}

static void
t_h_base_service_get_region_location_args_class_init (THBaseServiceGetRegionLocationArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_get_region_location_args_read;
  struct_class->write = t_h_base_service_get_region_location_args_write;

  gobject_class->finalize = t_h_base_service_get_region_location_args_finalize;
  gobject_class->get_property = t_h_base_service_get_region_location_args_get_property;
  gobject_class->set_property = t_h_base_service_get_region_location_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_ARGS_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_ARGS_RELOAD,
     g_param_spec_boolean ("reload",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
t_h_base_service_get_region_location_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceGetRegionLocationArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_get_region_location_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceGetRegionLocationArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_get_region_location_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceGetRegionLocationArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceGetRegionLocationResultProperties
{
  PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_RESULT_0,
  PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_RESULT_SUCCESS,
  PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_RESULT_IO
};

/* reads a t_h_base_service_get_region_location_result object */
static gint32
t_h_base_service_get_region_location_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceGetRegionLocationResult * this_object = T_H_BASE_SERVICE_GET_REGION_LOCATION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_get_region_location_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceGetRegionLocationResult * this_object = T_H_BASE_SERVICE_GET_REGION_LOCATION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceGetRegionLocationResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_get_region_location_result_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  THBaseServiceGetRegionLocationResult *self = T_H_BASE_SERVICE_GET_REGION_LOCATION_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_get_region_location_result_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  THBaseServiceGetRegionLocationResult *self = T_H_BASE_SERVICE_GET_REGION_LOCATION_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_get_region_location_result_instance_init (THBaseServiceGetRegionLocationResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_T_H_REGION_LOCATION, NULL);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
t_h_base_service_get_region_location_result_finalize (GObject *object)
{
  THBaseServiceGetRegionLocationResult *tobject = T_H_BASE_SERVICE_GET_REGION_LOCATION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
t_h_base_service_get_region_location_result_class_init (THBaseServiceGetRegionLocationResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_get_region_location_result_read;
  struct_class->write = t_h_base_service_get_region_location_result_write;

  gobject_class->finalize = t_h_base_service_get_region_location_result_finalize;
  gobject_class->get_property = t_h_base_service_get_region_location_result_get_property;
  gobject_class->set_property = t_h_base_service_get_region_location_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_T_H_REGION_LOCATION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_REGION_LOCATION_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_get_region_location_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceGetRegionLocationResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_get_region_location_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceGetRegionLocationResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_get_region_location_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceGetRegionLocationResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceGetAllRegionLocationsArgsProperties
{
  PROP_T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_ARGS_0,
  PROP_T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_ARGS_TABLE
};

/* reads a t_h_base_service_get_all_region_locations_args object */
static gint32
t_h_base_service_get_all_region_locations_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceGetAllRegionLocationsArgs * this_object = T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_ARGS(object);
  gboolean isset_table = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_table)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_get_all_region_locations_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceGetAllRegionLocationsArgs * this_object = T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceGetAllRegionLocationsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_get_all_region_locations_args_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  THBaseServiceGetAllRegionLocationsArgs *self = T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_ARGS_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_get_all_region_locations_args_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  THBaseServiceGetAllRegionLocationsArgs *self = T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_ARGS_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_get_all_region_locations_args_instance_init (THBaseServiceGetAllRegionLocationsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
}

static void 
t_h_base_service_get_all_region_locations_args_finalize (GObject *object)
{
  THBaseServiceGetAllRegionLocationsArgs *tobject = T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
}

static void
t_h_base_service_get_all_region_locations_args_class_init (THBaseServiceGetAllRegionLocationsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_get_all_region_locations_args_read;
  struct_class->write = t_h_base_service_get_all_region_locations_args_write;

  gobject_class->finalize = t_h_base_service_get_all_region_locations_args_finalize;
  gobject_class->get_property = t_h_base_service_get_all_region_locations_args_get_property;
  gobject_class->set_property = t_h_base_service_get_all_region_locations_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_ARGS_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_get_all_region_locations_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceGetAllRegionLocationsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_get_all_region_locations_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceGetAllRegionLocationsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_get_all_region_locations_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceGetAllRegionLocationsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceGetAllRegionLocationsResultProperties
{
  PROP_T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_RESULT_0,
  PROP_T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_RESULT_SUCCESS,
  PROP_T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_RESULT_IO
};

/* reads a t_h_base_service_get_all_region_locations_result object */
static gint32
t_h_base_service_get_all_region_locations_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceGetAllRegionLocationsResult * this_object = T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              THRegionLocation * _elem69 = NULL;
              if ( _elem69 != NULL)
              {
                g_object_unref (_elem69);
              }
              _elem69 = g_object_new (TYPE_T_H_REGION_LOCATION, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem69), protocol, error)) < 0)
              {
                g_object_unref (_elem69);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem69);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_get_all_region_locations_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceGetAllRegionLocationsResult * this_object = T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceGetAllRegionLocationsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i70;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i70 = 0; i70 < (this_object->success ? this_object->success->len : 0); i70++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i70))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_get_all_region_locations_result_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  THBaseServiceGetAllRegionLocationsResult *self = T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_get_all_region_locations_result_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  THBaseServiceGetAllRegionLocationsResult *self = T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_get_all_region_locations_result_instance_init (THBaseServiceGetAllRegionLocationsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
t_h_base_service_get_all_region_locations_result_finalize (GObject *object)
{
  THBaseServiceGetAllRegionLocationsResult *tobject = T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
t_h_base_service_get_all_region_locations_result_class_init (THBaseServiceGetAllRegionLocationsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_get_all_region_locations_result_read;
  struct_class->write = t_h_base_service_get_all_region_locations_result_write;

  gobject_class->finalize = t_h_base_service_get_all_region_locations_result_finalize;
  gobject_class->get_property = t_h_base_service_get_all_region_locations_result_get_property;
  gobject_class->set_property = t_h_base_service_get_all_region_locations_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_GET_ALL_REGION_LOCATIONS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_get_all_region_locations_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceGetAllRegionLocationsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_get_all_region_locations_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceGetAllRegionLocationsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_get_all_region_locations_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceGetAllRegionLocationsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceCheckAndMutateArgsProperties
{
  PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_0,
  PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_TABLE,
  PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_ROW,
  PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_FAMILY,
  PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_QUALIFIER,
  PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_COMPARE_OP,
  PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_VALUE,
  PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_ROW_MUTATIONS
};

/* reads a t_h_base_service_check_and_mutate_args object */
static gint32
t_h_base_service_check_and_mutate_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceCheckAndMutateArgs * this_object = T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS(object);
  gboolean isset_table = FALSE;
  gboolean isset_row = FALSE;
  gboolean isset_family = FALSE;
  gboolean isset_qualifier = FALSE;
  gboolean isset_compareOp = FALSE;
  gboolean isset_rowMutations = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->family != NULL)
          {
            g_free(this_object->family);
            this_object->family = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->family = g_byte_array_new();
          g_byte_array_append (this_object->family, (guint8 *) data, (guint) len);
          g_free (data);
          isset_family = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->qualifier != NULL)
          {
            g_free(this_object->qualifier);
            this_object->qualifier = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->qualifier = g_byte_array_new();
          g_byte_array_append (this_object->qualifier, (guint8 *) data, (guint) len);
          g_free (data);
          isset_qualifier = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          gint32 ecast71;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast71, error)) < 0)
            return -1;
          xfer += ret;
          this_object->compareOp = (TCompareOp)ecast71;
          isset_compareOp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->value = g_byte_array_new();
          g_byte_array_append (this_object->value, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->rowMutations), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_rowMutations = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_table)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_row)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_family)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_qualifier)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_compareOp)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_rowMutations)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
t_h_base_service_check_and_mutate_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceCheckAndMutateArgs * this_object = T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceCheckAndMutateArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "family", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->family ? ((GByteArray *) this_object->family)->data : NULL, this_object->family ? ((GByteArray *) this_object->family)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "qualifier", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->qualifier ? ((GByteArray *) this_object->qualifier)->data : NULL, this_object->qualifier ? ((GByteArray *) this_object->qualifier)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "compareOp", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->compareOp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->value ? ((GByteArray *) this_object->value)->data : NULL, this_object->value ? ((GByteArray *) this_object->value)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rowMutations", T_STRUCT, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->rowMutations), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_check_and_mutate_args_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  THBaseServiceCheckAndMutateArgs *self = T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_FAMILY:
      if (self->family != NULL)
        g_byte_array_unref (self->family);
      self->family = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_QUALIFIER:
      if (self->qualifier != NULL)
        g_byte_array_unref (self->qualifier);
      self->qualifier = g_value_dup_boxed (value);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_COMPARE_OP:
      self->compareOp = g_value_get_int (value);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_VALUE:
      if (self->value != NULL)
        g_byte_array_unref (self->value);
      self->value = g_value_dup_boxed (value);
      self->__isset_value = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_ROW_MUTATIONS:
      if (self->rowMutations != NULL)
        g_object_unref (self->rowMutations);
      self->rowMutations = g_value_dup_object (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_check_and_mutate_args_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  THBaseServiceCheckAndMutateArgs *self = T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_FAMILY:
      g_value_set_boxed (value, self->family);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_QUALIFIER:
      g_value_set_boxed (value, self->qualifier);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_COMPARE_OP:
      g_value_set_int (value, self->compareOp);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_VALUE:
      g_value_set_boxed (value, self->value);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_ROW_MUTATIONS:
      g_value_set_object (value, self->rowMutations);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_check_and_mutate_args_instance_init (THBaseServiceCheckAndMutateArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
  object->row = NULL;
  object->family = NULL;
  object->qualifier = NULL;
  object->value = NULL;
  object->__isset_value = FALSE;
  object->rowMutations = g_object_new (TYPE_T_ROW_MUTATIONS, NULL);
}

static void 
t_h_base_service_check_and_mutate_args_finalize (GObject *object)
{
  THBaseServiceCheckAndMutateArgs *tobject = T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->family != NULL)
  {
    thrift_string_free(tobject->family);
    tobject->family = NULL;
  }
  if (tobject->qualifier != NULL)
  {
    thrift_string_free(tobject->qualifier);
    tobject->qualifier = NULL;
  }
  if (tobject->value != NULL)
  {
    thrift_string_free(tobject->value);
    tobject->value = NULL;
  }
  if (tobject->rowMutations != NULL)
  {
    g_object_unref(tobject->rowMutations);
    tobject->rowMutations = NULL;
  }
}

static void
t_h_base_service_check_and_mutate_args_class_init (THBaseServiceCheckAndMutateArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_check_and_mutate_args_read;
  struct_class->write = t_h_base_service_check_and_mutate_args_write;

  gobject_class->finalize = t_h_base_service_check_and_mutate_args_finalize;
  gobject_class->get_property = t_h_base_service_check_and_mutate_args_get_property;
  gobject_class->set_property = t_h_base_service_check_and_mutate_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_FAMILY,
     g_param_spec_boxed ("family",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_QUALIFIER,
     g_param_spec_boxed ("qualifier",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_COMPARE_OP,
     g_param_spec_int ("compareOp",
                       NULL,
                       NULL,
                       0,
                       6,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_VALUE,
     g_param_spec_boxed ("value",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_ARGS_ROW_MUTATIONS,
     g_param_spec_object ("rowMutations",
                         NULL,
                         NULL,
                         TYPE_T_ROW_MUTATIONS,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_check_and_mutate_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceCheckAndMutateArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_check_and_mutate_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceCheckAndMutateArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_check_and_mutate_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceCheckAndMutateArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _THBaseServiceCheckAndMutateResultProperties
{
  PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_RESULT_0,
  PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_RESULT_SUCCESS,
  PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_RESULT_IO
};

/* reads a t_h_base_service_check_and_mutate_result object */
static gint32
t_h_base_service_check_and_mutate_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  THBaseServiceCheckAndMutateResult * this_object = T_H_BASE_SERVICE_CHECK_AND_MUTATE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_T_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_h_base_service_check_and_mutate_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  THBaseServiceCheckAndMutateResult * this_object = T_H_BASE_SERVICE_CHECK_AND_MUTATE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "THBaseServiceCheckAndMutateResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_h_base_service_check_and_mutate_result_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  THBaseServiceCheckAndMutateResult *self = T_H_BASE_SERVICE_CHECK_AND_MUTATE_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_h_base_service_check_and_mutate_result_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  THBaseServiceCheckAndMutateResult *self = T_H_BASE_SERVICE_CHECK_AND_MUTATE_RESULT (object);

  switch (property_id)
  {
    case PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_h_base_service_check_and_mutate_result_instance_init (THBaseServiceCheckAndMutateResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
t_h_base_service_check_and_mutate_result_finalize (GObject *object)
{
  THBaseServiceCheckAndMutateResult *tobject = T_H_BASE_SERVICE_CHECK_AND_MUTATE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
t_h_base_service_check_and_mutate_result_class_init (THBaseServiceCheckAndMutateResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_h_base_service_check_and_mutate_result_read;
  struct_class->write = t_h_base_service_check_and_mutate_result_write;

  gobject_class->finalize = t_h_base_service_check_and_mutate_result_finalize;
  gobject_class->get_property = t_h_base_service_check_and_mutate_result_get_property;
  gobject_class->set_property = t_h_base_service_check_and_mutate_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_H_BASE_SERVICE_CHECK_AND_MUTATE_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_T_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
t_h_base_service_check_and_mutate_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (THBaseServiceCheckAndMutateResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_h_base_service_check_and_mutate_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (THBaseServiceCheckAndMutateResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_h_base_service_check_and_mutate_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "THBaseServiceCheckAndMutateResultType",
                                   &type_info, 0);
  }

  return type;
}

